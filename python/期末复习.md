# Python程序设计期末复习

## 📘 第1章 Python语言概述

### 考点1：Python发展

#### 典型题（PPT Practice p.40）
>
> 缩进的作用及形式？  
答：  

- 用缩进表示代码块归属（如 `if`/`for`/`def` 内部）  
- 缩进结束表示代码块结束  
- 行尾冒号 `:` 表示缩进开始  
- 一般缩进 **4 空格**（不是 Tab！）

> 两种添加注释的方法？  
答：  

- `#` 单行注释  
- `'''...'''` 或 `"""..."""` 多行注释（独立成块，不在语句后）

---

### 考点2：开发环境与编程规范（中频，常结合代码改错）

| 知识点 | 考试要点 |
|:--------|:----------|
| IDE推荐 | 课程用 **Spyder**；其他：PyCharm, VS Code, IDLE |
| 缩进规则 | ❗**不可混用空格与Tab**；同一层级缩进量必须一致 |
| 命名规范 | 变量/函数：`snake_case` 或 `camelCase` 不做强制，但**禁用关键字**（如 `class`, `def`, `if`）<br>不可以~~数字开头~~<br>切勿使用！，@，#，$，％等~~特殊符号~~<br>P.S **中文是可以的** |
| 导入顺序 | ① 标准库 → ② 第三方库 → ③ 自定义模块；每类各占一行 |

#### 典型题（作业 homework1.txt）
>
> 使用 `pip install requests` 后，`pip list` 输出长什么样？  
答案要点：  

- 按字母排序  
- 每行：`包名 + 空格对齐 + 版本号`  
- 有 `requests == 2.32.5` 这行即算对（你作业中已正确列出）

---

### 考点3：扩展库安装与导入（高频！常考填空/代码补全）

| 方法 | 语法 | 说明 |
|:------|:------|:------|
| 在线安装 | `pip install SomePackage` | Spyder 中加 `!`：`!pip install numpy` |
| 离线安装 | `pip install package.whl` | 需手动解决依赖 |
| 清华镜像 | `pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy` | 国内加速必备 |
| 导入方式 | ① `import math` ② `from math import sin` ③ `from math import *` | 考察 `ceil(1.2)` 对应哪种导入（见 PPT p.56）

#### 典型题（PPT 习题 p.56）
>
> 为正确调用 `math.ceil(1.2)`，对以下三行应分别用什么导入语句？  

```python
ceil(1.2)
math.ceil(1.2)
mt.ceil(1.2)
```

答：

1. `from math import *`  
2. `import math`  
3. `import math as mt`

---

### 考点4：标准库认知（低频，但易混淆）

| 模块 | 典型用途 | 导入示例 |
|:------|:----------|:----------|
| `math` | 数学函数（`sin`, `log`, `ceil`） | `import math` |
| `random` | 随机数（`random()`, `randint()`） | `from random import *` |
| `os` | 文件/路径操作 | `import os.path as path` |
| `json` | JSON读写 | `import json` |

> ⚠️ 老师偏好对比题：  
> `import math` vs `from math import sin` 的区别？  
答：  

- 前者访问需 `math.sin()`，后者直接 `sin()`  
- 前者更安全（避免命名冲突）；后者访问略快（少一次属性查找）

---

📌 **Python基础复习建议**：  

- ✍️ 手写 `pip` 常用命令表（安装/卸载/列表/升级）  
- ✍️ 默写三种 `import` 方式 + 对应调用形式  
- 重点练：**缩进错误识别**（如 PPT p.30 的 `IndentationError`）

---

## 📘 第2章 内置对象、运算符与表达式

> ✅ 本章是整个 Python 的地基，占比 30%+，**几乎每道编程题都依赖本章知识**  
> ❗⚠️ 你作业中暴露的典型问题：
>
> - 实数比较直接用 `==`（homework2）  
> - 三元运算符写错位置（homework3）  
> - 赋值 vs 浅拷贝傻傻分不清（homework_4.3.1and2）  

---

### 考点1：**变量与赋值——Python 是“贴标签”，不是“装盒子”**

>
> `x = 3` 的意思是：**给对象 `3` 贴了个标签 `x`**；  
> `x = 'abc'` 是：**把 `x` 从 `3` 上撕下来，贴到 `'abc'` 上**。

#### 典型考题（来自 homework2.txt & PPT Practice）

| 题目 | 你写的 | 正确答案 | 解析 |
|:------|:--------|:----------|:------|
| `x = 3; y = x; x = x + 6; print(id(y))` | —— | `id(y) == id(3)` ✅ | `y` 仍贴在 `3` 上，`x` 已改贴 `9` |
| `x = [1, 2]; b = x; b[0] = 0; print(x)` | —— | `[0, 2]` ✅ | `x` 和 `b` 贴在同一块内存 → **修改共享** |
| `a = [[1,2],3]; b = a.copy(); b[0][0]=0; print(a)` | —— | `[[0,2],3]` ✅ | `copy()` 是**浅拷贝** → 内层列表仍共享 |

> 💡 **变量与赋值避坑口诀**：
>
> - 数字/字符串等**不可变对象**：贴新标签 = 新对象  
> - 列表/字典等**可变对象**：多标签 = 共享修改  
> - 想彻底独立？用 `import copy; b = copy.deepcopy(a)`

---

### 考点2：**三大数字类型与精度陷阱**

#### 📌 必背表格

| 类型 | 创建方式 | 特点 | 作业考题 |
|:------|:----------|:------|:----------|
| `int` | `3`, `0b101`（二进制） | 任意精度（`999**999` 不爆） | — |
| `float` | `3.0`, `1e5` | **16位精度**，比较慎用 `==` | homework2：`0.4-0.1==0.3` → `False` |
| `complex` | `3+4j`, `complex(3,4)` | `.real`, `.imag` 是 `float` | homework2：`abs(5+12j)` → `13.0` (`float`) |

#### 典型题 & 规范写法

```python
# ❌ 错误：直接比较 float
if 0.4 - 0.1 == 0.3: ...

# ✅ 正确：用误差范围
if abs((0.4 - 0.1) - 0.3) < 1e-6: ...

# ✅ 取模/余数（老师爱考）
print(10 % 3)    # 1
print(-10 % 3)   # 2（Python 余数 ≥0）
```

> 💡 记住：**float 比较永远用 `abs(a-b) < 1e-6`**

---

### 考点3：**四大容器类型速查表（考试默写重点！）**

| 容器 | 创建 | 可变？ | 有序？ | 查找速度 | 典型考题 |
|:------|:------|:--------|:--------|:----------|:----------|
| `list` | `[1,2,3]` | ✅ | ✅ | 慢 O(n) | homework2：`a=[1,[0,0],[0,0]]` 改为 `[1,[2,3],[4,5]]` |
| `tuple` | `(1,2,3)` 或 `1,2,3` | ❌ | ✅ | 慢 O(n) | homework2：`(1,2,3) == (1.0,2.0,3.0)` → `True` |
| `dict` | `{'a':1}` | ✅ | ❌ | 快 O(1) | homework_4.3.3：`d = {c: randint(0,10) for c in 'abc...'}` |
| `set` | `{1,2,3}` | ✅ | ❌ | 快 O(1) | homework_4.3.3：`set(a) <= set(b)` 判断子集 |

#### ⚠️ 四大容器易错细节

- `()` 是空元组；`{}` 是空字典；空集合只能 `set()`  
- 单元素元组必须加逗号：`(3,)` ✅，`(3)` ❌ = `3`  
- `dict` 的 key 必须**可哈希**（不可变）：`{[1,2]:3}` → ❌

---

### 考点4：**== vs is —— 值相等 vs 同一块内存**

| 运算符 | 含义 | 典型考题 | 正确答案 |
|:--------|:------|:----------|:----------|
| `==` | 值相等 | `(1,2,3) == (1.0,2.0,3.0)` | `True`（数值相等） |
| `is` | 内存地址相同 | `(1,2,3) is (1.0,2.0,3.0)` | `False`（不同对象） |

#### 记忆技巧

```python
x = [1, 2]
y = [1, 2]
print(x == y)   # True  值一样
print(x is y)   # False 地址不同

a = 256
b = 256
print(a is b)   # True  Python 小整数缓存 -5 ~ 256
a = 257
b = 257
print(a is b)   # False 超出缓存，新建对象
```

> ✅ **唯一推荐用 `is` 的场景**：`if x is None:`

---

### 考点5：**逻辑运算 `and`/`or` —— 返回的是“值”，不是 `True`/`False`！**

| 表达式 | 返回值 | 解释 |
|:--------|:--------|:------|
| `0.1 and 1` | `1` | `0.1` 真 → 返回 `1` |
| `[] or 1` | `1` | `[]` 假 → 返回 `1` |
| `'a' or 1` | `'a'` | `'a'` 真 → 返回 `'a'` |

#### 考试高频应用（来自 homework2）

| 题号 | 你的答案 | 评分 |
|:------|:----------|:------|
| `0.1 and 1` | `1` | ✅ |
| `[] or 1` | `1` | ✅ |
| `'a' or 1` | `'a'` | ✅ |

> 💡 `x or y` = “**拿第一个真值，没有就拿最后一个**”  
> `x and y` = “**拿第一个假值，没有就拿最后一个**”

---

### 考点6：**成员测试 `in` vs 同一性 `is` vs 等值 `==`**

| 操作 | 语法 | 适用对象 | 示例 |
|:------|:------|:----------|:-----|
| 成员测试 | `x in seq` | `list/tuple/str/set/dict`（dict 查 key） | `'a' in 'abc'` → `True`<br>`3 in {1,2,3}` → `True`<br>`'a' in {'a':1}` → `True` |
| 同一性测试 | `x is y` | 所有对象 | 见上一节 |
| 等值测试 | `x == y` | 所有对象 | 见上一节 |

#### 🛠️ 实用技巧（作业 4.3.3 第4题）

```python
a = [1]; b = [1,2,3,4]
# (1) a 所有元素 ∈ b
print(set(a) <= set(b))          # ✅ 推荐（快）

# (2) a 所有元素 ∉ b
print(not (set(a) & set(b)))    # ✅ 推荐（简洁）
# 你写：len(set(a)&set(b)) == 0 也可，但略啰嗦

# (3) a 至少一个 ∈ b
print(bool(set(a) & set(b)))    # ✅
# 你写：len(...) > 0 也可
```

> 🔥 **老师最爱考的集合运算符号**：
>
> - `A ⊆ B` → `set(A) <= set(B)`  
> - `A ∩ B = ∅` → `not (A & B)`  
> - `A ∪ B` → `A | B` （不是 `+`！）

---

### 考点7：**编码：UTF-8 vs GB2312（必考1分填空）**

| 字符 | UTF-8 字节数 | GB2312 字节数 |
|:------|:---------------|:---------------|
| `A`（英文） | 1 | 1 |
| `浙`（中文） | 3 | 2 |

#### 典型题（homework2）

```python
s = '浙江工业大学zjut'
print(len(s))           # → 10（字符数）
print(len(s.encode()))  # → 22（UTF-8 字节数：6×3 + 4×1）
```

> ✅ **作业满分写法**：
>
> ```python
> se = s.encode('utf-8')
> print(len(se))  # 22
> ```

---

### 考点8：内置函数 eval()（必考填空/选择）

> **`eval()` 的作用是“脱掉字符串的引号”，把剩下的内容当作 Python 代码执行。**

#### 🎯 典型题（易错！）
>
> 表达式 `eval('3*2'+'22')` 的值？

**解析步骤**：

1. **先拼接字符串**：`'3*2'` + `'22'` → `'3*222'`
2. **再执行代码**：`eval('3*222')` → 计算 $3 \times 222$
3. **结果**：`666`

#### ⚠️ 避坑口诀
>
> - `eval('1+1')` → `2` （执行数学运算）
> - `eval('"hello"')` → `'hello'` （脱掉外层引号，剩字符串）
> - `eval('print("hi")')` → 执行打印，返回 `None`

### 📝 内置对象复习 checklist（考前5分钟过一遍）

- [ ] `x = y` 是贴标签，不是复制 → 改 list 会联动  
- [ ] `float` 比较用 `abs(a-b) < 1e-6`  
- [ ] `list/tuple/dict/set` 创建方式 & 哪个可变/有序/快  
- [ ] `==` 比值，`is` 比地址；**只用 `is None`**  
- [ ] `and/or` 返回的是值，不是布尔  
- [ ] `set(a) <= set(b)` 是子集；`not (A & B)` 是无交集  
- [ ] 中文 UTF-8：3字节；GB2312：2字节  

---

## 📘 第3章 详解Python序列结构  
>
> ✅ 本章是**考试核心**，占卷面 35%+，重点考察：  
>
> - 列表的增删改查（作业4.3.1/2）  
> - 列表推导式（作业4.3.2/3）  
> - 切片（PPT Practice p.78）  
> - 生成器 vs 列表推导式（PPT p.129）  
> - 字典集合操作（作业4.3.3）  

---

### ✔️ 3.1 列表：打了激素的数组（高频！占本章 50%）

> **列表是“能变的数组”，所有增删操作默认在尾部最快，中间操作要拷贝、慢！**

---

#### 🎯 考点1：列表创建与浅拷贝（高频！）

| 方法 | 语法 | 是否拷贝 | 特点 | 你作业暴露问题 |
|:------|:------|:----------|:------|:----------------|
| `=` 赋值 | `b = a` | ❌（浅标签） | 同一块内存，改 `b` 影响 `a` | 未暴露（你避开了） |
| 切片拷贝 | `b = a[:]` | ✅（浅拷贝） | 新列表，但元素引用不变 | 未暴露 |
| `copy()` | `b = a.copy()` | ✅（浅拷贝） | 同切片 | 未暴露 |
| 深拷贝 | `b = copy.deepcopy(a)` | ✅（深） | 全新副本，嵌套也独立 | —— |

##### 🎯 典型题（PPT p.55）
>
> `[[1,2], 3] * 2` 的值？  
✅ 答：`[[1, 2], 3, [1, 2], 3]`  
⚠️ 注意：修改 `b[0][0]=0` ⇒ `a` 也变！——**浅拷贝陷阱**

##### ⚠️ 列表创建与浅拷贝避坑口诀
>
> **`*` 复制 ⇒ 浅拷贝！改内层 ⇒ 全部变！**

---

#### 🎯 考点2：列表增删方法（高频！作业4.3.1重点）

| 操作 | 方法 | 是否原地 | 优缺点 | 你作业满分写法 |
|:------|:------|:----------|:--------|:----------------|
| 尾部加 | `append(x)` | ✅ | 快 | ✔ 用 `for` + `append` 生成列表 |
| 尾部加多 | `extend(seq)` / `+=` | ✅ | 快 | —— |
| 中间插 | `insert(i,x)` | ✅ | 慢（要移动） | —— |
| 中间插多 | `a[i:i] = [x,y]` | ✅ | **唯一能一次插多个的方法！** | —— |
| 删首个x | `remove(x)` | ✅ | 慢；不存在报错 | ✔ 用 `for _ in range(count): remove()` |
| 删指定 | `pop(i)` | ✅ | 返回删的值 | —— |
| 删切片 | `del a[::2]` | ✅ | 批量删（切片不连续时**只能用 `del`**） | —— |

##### 🎯 典型题（作业4.3.1）

```python
# 2. 将 a 中 'a' 的下标存入 b
start = 0
for _ in range(a.count('a')):
    idx = a.index('a', start)  # 从 start 开始找，不重复头搜
    b.append(idx)
    start = idx + 1
```

✅ **优于** `enumerate` 逐个判断（当 `'a'` 极少时效率高）  
⚠️ 若写 `for i in range(len(a))` ⇒ 每次 `a.index('a')` 都从头搜 ⇒ 慢！

##### ⚠️ 列表增删方法避坑口诀
>
> - `remove()` **一次只删第一个** ⇒ 要循环删  
> - `index()` 加 `start` 参数 ⇒ 避免重复搜索  
> - 插多个 ⇒ 用 `a[i:i]= [...]`（`insert` 不行！）

---

#### 🎯 考点3：切片操作（高频！作业4.3.2手算题）

##### 🔑 切片三要素（必须背！）

```python
[start : end : step]
```

| 参数 | 省略时 | 含义 |
|:------|:--------|:------|
| `start` | `step>0` ⇒ `0`；`step<0` ⇒ `-1`（尾） | 起始下标 |
| `end` | `step>0` ⇒ `len`；`step<0` ⇒ `-len-1`（头前） | **截止**，不包含 |
| `step` | `1` | 步长；负值 ⇒ 逆序 |

##### 🎯 典型题（作业4.3.2手算）

```python
aList = list(range(2, 12))  # [2,3,4,5,6,7,8,9,10,11]
aList[-15:3]  # start=-15→0, end=3 ⇒ [2,3,4]
aList[9:0:-1] # 从9→1，不包含0 ⇒ [11,10,9,8,7,6,5,4,3]
```

##### ⚠️ 切片三避坑口诀
>
> - **`a[i]` 越界 ⇒ `IndexError`**；**`a[i:j]` 越界 ⇒ 截断/空**  
> - `step` 为负 ⇒ `start > end` 才有值  
> - `a[::-1]` 新列表；`a.reverse()` 原地改；`reversed(a)` 迭代器  

---

#### 🎯 考点4：列表推导式（高频！作业4.3.2/3核心）

##### 🔑 万能模板

```python
[expr for var in seq if cond]
```

##### 📌 必会 5 种题型（来自作业4.3.2）

| 需求 | 写法 | 你作业满分写法 |
|:------|:------|:----------------|
| 奇数平方 | `[x**2 for x in a if x % 2 == 1]` | ✔ |
| 奇数下标 | `[i for i, x in enumerate(a) if x % 2 == 1]` | ✔ 用 `enumerate` |
| 全偶判断 | `all(x % 2 == 0 for x in a)` | ✔ 用生成器（省内存） |
| 至少一偶 | `any(x % 2 == 0 for x in a)` | ✔ |
| 同位置不等相减 | `[x - y for x, y in zip(a, b) if x != y]` | ✔ |

##### ⚠️ 列表推导式避坑口诀
>
> - `all([...])` ⇒ 用生成器 `all(... for ...)`  
> - `enumerate()` ⇒ `(i, x)` 顺序别反  
> - `zip()` ⇒ 长度不同 ⇒ 以短为准  

---

### ✔️ 3.2 元组：轻量级列表（中频）

>
> **元组是“不能变的列表”，速度快、安全，可用作字典键！**

#### 🎯 考点1：元组 vs 列表（高频辨析题）

| 特性 | 元组 | 列表 |
|:------|:------|:------|
| 可变？ | ❌ | ✅ |
| 创建 | `(1,)` | `[1]` |
| 方法 | `count`, `index` | `append`, `remove`... |
| 内存 | 小 | 大 |
| 哈希 | ✅（可作 `dict` 键） | ❌ |

##### 🎯 典型题（PPT p.41）
>
> `[1,2]`, `{1,2}`, `(1,2)`, `{1:2}` 的类型？  
✅ 答：`list`, `set`, `tuple`, `dict`

##### ⚠️ 元组 vs 列表避坑口诀
>
> - 单元素元组 ⇒ **必须加逗号**：`(3,)` ✅；`(3)` ❌ = `3`  
> - 元组不可变 ⇒ 但内层可变对象仍可改：  
>
>   ```python
>   a = (1, [2, 3])
>   a[1][0] = 0  # ✅ 允许！改的是列表，不是元组
>   ```

---

#### 🎯 考点2：生成器推导式（高频！PPT p.129）

| 特性 | 生成器 `(x for x in a)` | 列表推导式 `[x for x in a]` |
|:------|:--------------------------|:-----------------------------|
| 内存 | 极低（只存状态） | 高（存所有结果） |
| 执行 | 惰性（用时才算） | 立即 |
| 复用 | ❌（一次性） | ✅ |
| 适用 | 大数据/无限序列 | 小数据/需复用 |

##### 🎯 典型题（PPT Practice p.129）

```python
g = (i**2 for i in range(0, 10, 2))  # 0,2,4,6,8
print(4 in g)   # True（找到 2²=4 即停）
print(list(g))  # [36, 64]（后续 6²,8²）
```

##### ⚠️ 生成器推导式避坑口诀
>
> - 生成器 ⇒ `()`；列表 ⇒ `[]`  
> - 遍历一次 ⇒ 耗尽；再遍历 ⇒ `[]`  
> - `all(i>0 for i in g)` ⇒ 比 `all([i>0 for i in a])` 省内存  

---

### ✔️ 3.3 字典：映射类型（高频！作业4.3.3）

>
> **字典是“键→值”的映射，键必须可哈希（不可变），查改快 O(1)！**

#### 🎯 考点1：字典创建与访问（高频）

| 方式 | 语法 | 特点 |
|:------|:------|:------|
| 直接 | `{'a':1}` | 最常用 |
| `dict()` | `dict(a=1, b=2)` | 键必须是合法变量名 |
| `zip` | `dict(zip(keys, vals))` | 你作业满分写法 ✔ |
| `fromkeys` | `dict.fromkeys(keys, 0)` | 统一初值 |

##### 📌 字典遍历（你作业4.3.3用到）

```python
scores = {"Zhang San": 99, "Li Si": 78}
# 找最高分同学
max_score = max(scores.values())
[k for k, v in scores.items() if v == max_score]  # ✔ 你用法完美
```

##### ⚠️ 字典避坑口诀
>
> - `d[key]` ⇒ 键不存在 ⇒ `KeyError`  
> - `d.get(key, default)` ⇒ 安全访问  
> - `d.setdefault(key, val)` ⇒ 不存在则设值  

---

#### 🎯 考点2：字典推导式（中频）

```python
# 作业4.3.3 第3题：值在 [6,9] 的键
[k for k, v in d.items() if 6 <= v <= 9]  # ✔ 你写 `5 < d[i] < 10` 等价
```

---

### ✔️ 3.4 集合：无重复元素（高频！作业4.3.3）

#### 🔑 集合核心一句话
>
> **集合是“不重复的无序容器”，查改快，专为集合运算设计！**

#### 🎯 考点：集合运算符（高频辨析题）

| 运算 | 运算符 | 方法 | 你作业写法 |
|:------|:--------|:------|:------------|
| 并集 | `\|` | `union()` | —— |
| 交集 | `&` | `intersection()` | ✔ `set(a) & set(b)` |
| 差集 | `-` | `difference()` | ✔ `not (set(a) & set(b))` |
| 对称差 | `^` | `symmetric_difference()` | PPT p.190：`{1,2,3,4} ^ {2,3,5} = {1,4,5}` |

##### 📌 3 大经典判断（作业4.3.3）

```python
# (1) a ⊆ b
set(a) <= set(b)  # 你写法 ✔

# (2) a ∩ b = ∅
not (set(a) & set(b))  # 你写 `len==0` ✔；但 `not` 更简洁

# (3) a ∩ b ≠ ∅
bool(set(a) & set(b))  # 你写 `len>0` ✔
```

##### ⚠️ 集合运算符避坑口诀
>
> - 空集合 ⇒ `set()`；`{}` 是空字典！  
> - `remove()` ⇒ 不存在 ⇒ 报错；`discard()` ⇒ 静默忽略  
> - 集合元素 ⇒ 必须可哈希（不能有 `list`/`dict`/`set`）  

---

### ✔️ 3.5 序列解包（中频）

#### 🔑 序列核心一句话
>
> **`a, b = [1, 2]` 是解包；`first, *mid, last = seq` 是扩展解包！**

##### 🎯 典型应用

```python
# 交换变量
a, b = b, a

# 遍历键值对
for k, v in d.items(): ...

# 解包不定长
first, *middle, last = [1,2,3,4,5]
# first=1, middle=[2,3,4], last=5
```

##### ⚠️ 序列解包避坑口诀
>
> - 元素数 ≠ 变量数 ⇒ `ValueError`  
> - 集合解包 ⇒ 顺序随机（不推荐）  

---

### 📝 Python序列结构复习 Checklist（考前5分钟速过）

- [ ] `*` 复制列表 ⇒ 浅拷贝；改内层 ⇒ 全部变  
- [ ] `remove()` 一次删一个；删多个 ⇒ 循环  
- [ ] 切片越界不报错；`a[i]` 越界报错  
- [ ] `a[::-1]` 新列表；`a.reverse()` 原地改  
- [ ] 列表推导式 `all(... for ...)` 用生成器更省内存  
- [ ] 元组单元素 ⇒ `(x,)` 必须加逗号  
- [ ] 生成器一次性；遍历完为空  
- [ ] 字典安全访问 ⇒ `get()`；初始化 ⇒ `setdefault()`  
- [ ] 集合空 ⇒ `set()`；`{}` 是字典  
- [ ] 集合判断：`⊆` ⇒ `<=`；无交集 ⇒ `not (A & B)`  

---

## 📘 第5章 函数  
>
> ✅ 本章是**编程思想的核心**，占卷面 30%+，重点考察：  
>
> - 函数定义、参数传递（作业5.5）  
> - 变量作用域（PPT p.74-78）  
> - 递归函数（作业5.5 题1）  
> - 修饰器（作业5.5 题2）  
> - lambda 表达式（PPT p.83）  
> - 生成器函数（PPT p.94）

---

### ✔️ 5.1 函数定义与调用（高频！）

#### 🔑 函数定义与调用核心一句话
>
> `def` 定义函数，`return` 返回值；不写 `return` 或只写 `return` → 自动返回 `None`。

#### 🎯 考点1：函数基本语法（必考填空/改错）

| 要素 | 规则 | 你作业暴露问题 |
|:------|:------|:----------------|
| `def` | 必须有，后跟函数名和 `()` | —— |
| 冒号 `:` | `def` 行末必须有 | —— |
| 缩进 | 函数体必须缩进 | —— |
| `return` | 可选；无 `return` → `None` | 未暴露 |

##### 🎯 典型题（PPT Practice p.13）
>
> Python 函数在什么情况下返回 `None`？  
✅ 答：  

1. 没有 `return` 语句  
2. 有 `return` 但没执行到  
3. 执行了 `return` 但没有表达式（即 `return` 后为空）

##### ⚠️ 函数定义与调用避坑口诀
>
> **凡是有 `return` 的函数，要么返回一个值，要么返回 `None`。**

---

### ✔️ 5.2 函数参数（高频！）

#### 🔑 函数参数核心一句话
>
> 参数传递是**对象引用传递**，不是 C 语言的值传递或指针传递！

#### 🎯 考点1：四种参数类型（高频辨析）

| 类型 | 语法 | 特点 | 你作业满分写法 |
|:------|:------|:------|:----------------|
| 位置参数 | `def f(a, b):` | 顺序必须一致 | —— |
| 默认值参数 | `def f(a=1):` | 可省略，定义时解释一次 | —— |
| 关键字参数 | `f(b=2)` | 调用时指定名字，可乱序 | —— |
| 可变长度参数 | `*args`, `**kwargs` | 接收任意多的位置/关键词参数 | —— |

##### 🎯 典型题（PPT p.61）

```python
def demo(*args, **kwargs):
    print(args)
    print(kwargs)

demo(1, 2, a=1, b=2)
```

✅ 输出：  

```python
(1, 2)
{'a': 1, 'b': 2}
```

##### ⚠️ 函数参数避坑口诀
>
> - **位置参数在前，关键字参数在后** ⇒ `f(1, b=2)` ✅；`f(b=2, 1)` ❌  
> - `*args` 是元组，`**kwargs` 是字典  
> - 默认值参数不要用可变对象（如 `def f(x=[])`）⇒ 多次调用会共享列表！

---

### ✔️ 5.3 变量作用域（高频！易混淆）

#### 🔑 变量作用域核心一句话
>
> **函数内部优先用局部变量；要改全局变量，必须 `global` 声明；嵌套函数要用外层变量，必须 `nonlocal` 声明！**

#### 🎯 考点1：局部 vs 全局变量（高频选择/判断）

| 场景 | 代码 | 结果 | 解析 |
|:------|:------|:------|:------|
| 局部覆盖全局 | ```python<br>a = 10<br>def func():<br>    a = 20<br>    print(f"局部 {a}")<br>func()<br>print(f"全局 {a}")<br>``` | 局部 20<br>全局 10 | 函数内 `a=20` 创建了新的局部变量 |
| 尝试修改全局 | ```python<br>a = 10<br>def func():<br>    a += 1 # 报错！<br>func()<br>``` | `UnboundLocalError` | 因为 `a += 1` 包含赋值，Python 认为 `a` 是局部变量，但读取时未初始化 |
| 正确修改全局 | ```python<br>a = 10<br>def func():<br>    global a<br>    a += 1<br>func()<br>print(a) # 11<br>``` | ✅ | 加 `global a` 声明 |

##### 🎯 考点2：嵌套函数与 `nonlocal`（中频）

```python
def outer():
    x = 5
    def inner():
        nonlocal x  # 不加这行会报错！
        x = x + 1
        print(x)
    inner()
    print(x)

outer()
```

✅ 输出：`6` `6`（内外都改了）

##### ⚠️ 变量作用域避坑口诀
>
> - 函数内**只要出现对变量的赋值**，该变量就默认是**局部变量**  
> - 想改全局 ⇒ `global var`  
> - 想改外层函数的变量 ⇒ `nonlocal var`  
> - 不想改 ⇒ 别赋值，直接读

---

### ✔️ 5.4 lambda 表达式（中频）

#### 🔑 lambda 表达式核心一句话
>
> `lambda` 是一行函数，格式：`lambda 参数: 表达式`；常用于 `key=` 参数。

#### 🎯 考点：`lambda` 应用（PPT p.83）

| 用途 | 代码 | 说明 |
|:------|:------|:------|
| `max()`/`min()` | `max([(1,2), (3,4)], key=lambda x: x[1])` | 按第二个元素比大小 |
| `sorted()` | `sorted(['aa', 'b'], key=lambda s: len(s))` | 按长度排序 |
| `map()`/`filter()` | `list(map(lambda x: x**2, [1,2,3]))` | 平方映射 |

##### ⚠️ lambda 表达式避坑口诀
>
> - `lambda` 只能包含**一个表达式**，不能有 `if-else` 语句（可用三元运算符 `x if cond else y`）  
> - `lambda` 中尽量**别用全局变量**，容易出错  
> - 能用列表推导式就别用 `map()`+`lambda`

---

### ✔️ 5.5 生成器函数设计要点（高频！）

#### 🔑 生成器函数核心一句话
>
> **普通函数用 `return` 返回并结束；生成器函数用 `yield` 暂停并返回一个值，下次从这里继续！**

#### 🎯 考点1：`yield` vs `return`（高频对比）

| 特性 | 普通函数 (`return`) | 生成器函数 (`yield`) |
|:------|:---------------------|:------------------------|
| 返回值 | 一次性返回所有结果 | 每次 `yield` 返回一个 |
| 执行方式 | 一次性运行完 | 惰性求值，按需生成 |
| 内存占用 | 存所有结果 | 只存当前状态 |
| 可迭代性 | 返回的可能是列表 | 函数本身是生成器对象 |

##### 🎯 典型题（PPT p.94）

```python
def f():
    n = 0
    while n <= 3:
        yield n
        n += 1

g = f()  # g 是生成器对象
print(next(g))  # 0
print(next(g))  # 1
for i in g:     # 继续从 2 开始
    print(i)    # 2, 3
```

##### 🎯 考点2：生成器表达式（中频）

```python
# 生成器表达式（省内存）
squares_gen = (x**2 for x in range(5))
print(list(squares_gen))  # [0, 1, 4, 9, 16]
print(list(squares_gen))  # [] ← 已耗尽！

# 对比：列表推导式（费内存）
squares_list = [x**2 for x in range(5)]
print(squares_list)  # [0, 1, 4, 9, 16]
print(squares_list)  # [0, 1, 4, 9, 16] ← 还在
```

##### ⚠️ 生成器函数避坑口诀
>
> - `yield` ⇒ 生成器；`return` ⇒ 普通函数  
> - 生成器**只能遍历一次**！再遍历 ⇒ 空  
> - 大数据处理 ⇒ 用生成器，避免爆内存

---

### ✔️ 5.6 修饰器（Decorator）（高频压轴题！）

#### 🔑 修饰器核心一句话
>
> **修饰器是一个函数，它接收另一个函数作为参数，并返回一个包装后的函数，从而在不修改原函数代码的情况下增加功能。**

#### 🎯 考点：修饰器模板（作业5.5 题2）

```python
def our_decorator(func):
    def function_wrapper(*args, **kwargs):
        # 在这里打印所有位置参数
        for i, arg in enumerate(args):
            print(f"pos_arg[{i}] = {arg}", end=' ')
        # 在这里打印所有关键词参数
        for k, v in kwargs.items():
            print(f"{k} = {v}", end=' ')
        # 调用原函数
        result = func(*args, **kwargs)
        print(f"return = {result}")
        return result
    return function_wrapper

@our_decorator
def f(n, i):
    if n == i or i == 0:
        return 1
    return f(n-1, i) + f(n-1, i-1)

f(8, 3)  # 调用被修饰的函数
```

##### ⚠️ 修饰器避坑口诀
>
> - `@decorator` 是语法糖，等价于 `f = decorator(f)`  
> - `wrapper` 函数必须接受 `*args, **kwargs` 以兼容任意参数  
> - `wrapper` 最后必须 `return func(...)`，否则原函数返回值丢失  
> - `wrapper` 内部调用 `func` 时也要传 `*args, **kwargs`

---

### 📝 函数复习 Checklist（考前5分钟速过）

- [ ] 无 `return` 或 `return` 无值 ⇒ 返回 `None`  
- [ ] 参数传递是**对象引用**，不是值传递  
- [ ] 函数内赋值 ⇒ 变成局部变量 ⇒ 改全局必须 `global`  
- [ ] 嵌套函数改外层变量 ⇒ 必须 `nonlocal`  
- [ ] `lambda 参数: 表达式` ⇒ 一行匿名函数  
- [ ] `yield` ⇒ 暂停并返回；`return` ⇒ 结束并返回  
- [ ] 生成器只能遍历一次  
- [ ] 修饰器：`def dec(f): def w(*a,**k): ...; return f(*a,**k); return w`  

---

## 📘 第6章 面向对象程序设计  
>
> ✅ 本章是**高分关键**，占卷面 25%+，重点考察：  
>
> - 类的定义、`__init__`、实例属性/方法（作业5.6）  
> - 封装思想与 `@property`（PPT p.59-61）  
> - 继承与 `super()`（PPT p.65-70）  
> - 多态（PPT p.71-74）  
> - 特殊方法与运算符重载（PPT p.84-89）

---

### ✔️ 6.1 类和对象的概述（基础！必会）

#### 🔑 类和对象核心一句话
>
> **类是模板，对象是实例；每个对象有自己的数据（属性），但共享代码（方法）。**

---

### ✔️ 6.2 类的基本使用——实例属性和实例方法（高频！作业5.6核心）

#### 🎯 考点1：类定义与 `__init__` 构造方法（高频填空/改错）

| 要素 | 规则 | 你作业暴露问题 |
|:------|:------|:----------------|
| `class` | 必须有，后跟大写驼峰类名 | —— |
| `def __init__(self, ...)` | 构造方法，创建对象时自动调用 | —— |
| `self` | **必须是第一个参数**，代表当前对象 | —— |
| 实例属性 | `self.attr = value` | —— |

##### 🎯 典型题（作业5.6）

```python
class Student:
    def __init__(self, name, age, score):
        self.name = name
        self.age = age
        self.score = score
    
    def isPassed(self):
        return self.score >= 60

s = Student("小明", 19, 80)
print(s.isPassed())  # True
```

✅ 完全正确。注意 `isPassed()` 是**实例方法**，必须通过 `s.` 调用。

##### ⚠️ 类定义与 `__init__` 构造方法避坑口诀
>
> - `__init__` 只负责初始化，不打印！  
> - `self` 参数不能漏，但创建对象时不传（如 `Student(...)`）  
> - 实例属性用 `self.` 访问，否则就是局部变量！

---

#### 🎯 考点2：修改属性值（两种方式，考试常考对比）

| 方式 | 写法 | 是否推荐 | 理由 |
|:------|:------|:----------|:------|
| 直接赋值 | `s.age = 20` | ❌ | 破坏封装，无法控制有效性 |
| 通过方法 | `s.update_age(20)` | ✅ | 可加验证、日志等逻辑 |

##### 🎯 典型题（PPT p.24-25）

```python
class Student:
    def __init__(self, name, id):
        self.name = name
        self.id = id
        self.age = 19  # 默认值
    
    def update_age(self, new_age):
        if 1 <= new_age <= 150:  # 加验证
            self.age = new_age
        else:
            print("年龄无效！")

s = Student("小明", 202401)
s.update_age(20)  # 推荐！
```

##### ⚠️ 修改属性值避坑口诀
>
> - 想安全？**别直接 `obj.attr = x`**，用 `set_attr(x)` 方法  
> - `__dict__` 可看所有属性，但别乱改！

---

### ✔️ 6.3 类属性和类方法、静态方法（中频）

#### 🎯 考点1：类属性 vs 实例属性（高频辨析）

| 属性类型 | 创建位置 | 所属 | 访问方式 | 示例 |
|:----------|:----------|:------|:----------|:------|
| 实例属性 | `__init__` 或实例方法内 | 每个对象独有 | `obj.attr` | `s.name` |
| 类属性 | 在类体顶层 | 所有对象**共享** | `Class.attr` 或 `obj.attr` | `Student.count = 0` |

##### 🎯 典型题（PPT p.30）

```python
class Dog:
    species = "Canis lupus"  # 类属性（所有狗都一样）
    
    def __init__(self, name):
        self.name = name      # 实例属性（每只狗名字不同）

d1 = Dog("小巴")
d2 = Dog("小柴")
print(d1.species, d2.species)  # Canis lupus Canis lupus（相同）
```

##### ⚠️ 类属性 vs 实例属性避坑口诀
>
> - 类属性在**类体内部、方法外部**定义  
> - 修改类属性 ⇒ 用 `Dog.species = "..."`，不用 `d1.species = ...`（否则创建了同名实例属性！）

---

#### 🎯 考点2：类方法与静态方法（中频）

| 方法类型 | 语法 | 第一参数 | 能访问什么 | 典型用途 |
|:----------|:------|:----------|:------------|:----------|
| 实例方法 | `def func(self):` | `self` | 实例属性/方法 | 处理单个对象 |
| 类方法 | `@classmethod def func(cls):` | `cls` | **类属性/方法** | 工厂方法（如 `from_str`） |
| 静态方法 | `@staticmethod def func():` | 无 | **都不能** | 辅助函数（与类相关但不依赖状态） |

##### 🎯 典型题（PPT p.38 & 作业5.6补充）

```python
class Time:
    def __init__(self, h, m, s):
        self._h, self._m, self._s = h, m, s
    
    @classmethod
    def from_str(cls, s):
        """工厂方法：从字符串创建Time对象"""
        h, m, s = map(int, s.split(':'))
        return cls(h, m, s)  # cls 即 Time
    
    def is_time(self):
        """实例方法：判断时间是否合法"""
        return 0 <= self._m < 60 and 0 <= self._s < 60

# 使用
t = Time.from_str("10:5:20")  # 类方法调用
print(t.is_time())  # 实例方法调用
```

##### ⚠️ 类方法与静态方法避坑口诀
>
> - 类方法 ⇒ `@classmethod` + `cls` 参数  
> - 静态方法 ⇒ `@staticmethod` + 无 `self/cls`  
> - 工厂方法返回 `cls(...)`，不是硬编码 `Time(...)`

---

### ✔️ 6.4 私有属性和私有方法（中频）

#### 🎯 考点：`__attr` 与 `_attr`（易混淆！）

| 名称 | 写法 | 含义 | 能否外部访问？ |
|:------|:------|:------|:----------------|
| 私有属性 | `__attr` | Python 会改名为 `_ClassName__attr` | ❌（需 `obj._Class__attr`） |
| 约定私有 | `_attr` | 开发者约定“请勿访问” | ✅（能，但不该） |
| 公有属性 | `attr` | 正常公开 | ✅ |

##### 🎯 典型题（PPT p.58）

```python
class Student:
    def __init__(self, score):
        self.__score = score  # 私有属性

s = Student(100)
# print(s.__score)   # ❌ 报错！AttributeError
print(s._Student__score)  # ✅ 输出 100，但**不推荐**！
```

##### ⚠️ 私有属性和私有方法避坑口诀
>
> - `__xxx` 不是绝对私有，只是“障眼法”  
> - 真想保护？用 `@property` + `@setter`

---

### ✔️ 6.5 面向对象的三大特性（高频压轴！）

#### 🎯 考点1：继承（Inheritance）——单一继承（高频）

> **子类继承父类的所有公有成员，可添加新方法或重写旧方法。**

##### 🎯 典型题（PPT p.65-66）

```python
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def eat(self):
        print(f"{self.name}正在吃东西")

class Dog(Animal):  # Dog 继承 Animal
    pass  # 什么都不写，也能用父类的方法

my_dog = Dog("小汪", 4)
my_dog.eat()  # 小汪正在吃东西（继承而来）
```

##### ⚠️ OOP继承避坑口诀
>
> - 子类构造方法若要初始化父类属性 ⇒ 必须手动调 `super().__init__()`  
> - `super()` 是最佳实践，比 `Parent.__init__()` 更灵活

---

#### 🎯 考点2：多重继承（中频，了解即可）

```python
class Student:
    def stu_info(self):
        print("我是学生")

class Staff:
    def staff_info(self):
        print("我是职员")

class PartTimeStudent(Student, Staff):  # 继承两个类
    def __init__(self, name):
        self.name = name

p = PartTimeStudent("小明")
p.stu_info()    # 我是学生
p.staff_info()  # 我是职员
```

##### ⚠️ OOP多重继承避坑口诀
>
> - 方法查找顺序（MRO）：从左到右，深度优先  
> - 谨慎使用，避免复杂继承链

---

#### 🎯 考点3：多态（Polymorphism）——同一个方法，不同表现（高频！）

> **基类的方法，在不同子类中有不同的实现，调用时会根据对象自动选择。**

##### 🎯 典型题（PPT p.73-74）

```python
import math

class Graphic:
    def cal_square(self):
        pass  # 父类方法留空，让子类重写

class Triangle(Graphic):
    def __init__(self, base, height):
        self.base = base
        self.height = height
    
    def cal_square(self):
        square = 0.5 * self.base * self.height
        print(f"三角形面积是{square:.2f}")

class Circle(Graphic):
    def __init__(self, radius):
        self.radius = radius
    
    def cal_square(self):
        square = math.pi * self.radius ** 2
        print(f"圆面积是{square:.3f}")

# 多态体现
shapes = [Triangle(6, 8), Circle(3)]
for shape in shapes:
    shape.cal_square()  # 自动调用对应类的 cal_square()
```

✅ 输出：  

```
三角形面积是24.00
圆面积是28.274
```

##### ⚠️ 避坑口诀
>
> - 多态的前提是**继承**和**方法重写**  
> - “一个接口，多种实现”

---

### ✔️ 6.6 特殊方法与运算符重载（中频）

#### 🎯 考点1：`__str__` 和 `__repr__`（高频）

| 方法 | 何时调用 | 返回目的 | 你作业要求 |
|:------|:----------|:----------|:------------|
| `__str__` | `print(obj)` / `str(obj)` | 人看的，简洁 | —— |
| `__repr__` | `repr(obj)` / 交互式环境 | 解释器看的，可重建 | —— |

##### 🎯 典型题（PPT p.75-76）

```python
class Clock:
    def __init__(self, h, m, s):
        self.h, self.m, self.s = h, m, s
    
    def __str__(self):
        return f"时{self.h}，分{self.m}，秒{self.s}"
    
    def __repr__(self):
        return f"Clock({self.h},{self.m},{self.s})"

c = Clock(10, 20, 30)
print(c)           # 时10，分20，秒30 （__str__）
print(repr(c))     # Clock(10,20,30) （__repr__）
```

##### ⚠️ 特殊方法避坑口诀
>
> - `__str__` → `print()`；`__repr__` → `eval()` 友好  
> - 优先写 `__repr__`，`__str__` 缺省时会调用它

---

#### 🎯 考点2：运算符重载（中频）

```python
class Fraction:
    def __init__(self, num, den):
        self.num = num
        self.den = den
    
    def __add__(self, other):
        """支持 + 运算符"""
        new_num = self.num * other.den + other.num * self.den
        new_den = self.den * other.den
        return Fraction(new_num, new_den)
    
    def __str__(self):
        return f"{self.num}/{self.den}"

# 使用
f1 = Fraction(1, 2)
f2 = Fraction(1, 3)
print(f1 + f2)  # 5/6 （而不是 f1.add(f2)）
```

##### ⚠️ 运算符重载避坑口诀
>
> - `__add__` ⇒ `+`；`__sub__` ⇒ `-`；`__mul__` ⇒ `*`  
> - `other` 是另一个操作数

---

### 📝 OOP复习 Checklist（考前5分钟速过）

- [ ] `__init__` 是构造方法，`self` 必须是第一参数  
- [ ] 实例属性 ⇒ `self.attr`；类属性 ⇒ `ClassName.attr`  
- [ ] 类方法 ⇒ `@classmethod` + `cls`；静态方法 ⇒ `@staticmethod`  
- [ ] 私有属性 ⇒ `__attr`，外部访问用 `_Class__attr`（不推荐）  
- [ ] 继承 ⇒ `class Child(Parent):`；用 `super()` 调父类  
- [ ] 多态 ⇒ 父类引用指向子类对象，调用重写方法  
- [ ] `__str__` 为人读；`__repr__` 为机器读  
- [ ] 运算符重载 ⇒ `__add__`, `__eq__` 等特殊方法  

---

## 📘 第7章 字符串  
>
> ✅ 本章是**文本处理的核心**，占卷面 20%+，重点考察：  
>
> - 字符串格式化（`format()` vs `f-string`）  
> - 字符串方法（`split`, `join`, `strip`, `replace`）  
> - 切片与内置函数（`len`, `max`, `min`, `sorted`）  
> - 编码转换（`encode`/`decode`）  
> - 实际应用题：清洗、统计、拼接  

### ✔️ 7.1 字符串编码格式简介（高频！必考）

> **Python 中 `str` 是人类看的字符，`bytes` 是机器存的字节；用 `.encode()` 和 `.decode()` 转换。**

#### 🎯 考点1：UTF-8 vs GBK 字节数（高频填空）

| 字符类型 | UTF-8 字节数 | GBK 字节数 |
|:----------|:--------------|:------------|
| 英文（ASCII） | 1 | 1 |
| 汉字 | 3 | 2 |

##### 🎯 典型题（PPT Practice p.37 & homework2.txt）
>
> `'浙江工业大学zjut'` 的 UTF-8 编码长度？  
✅ 答案：6个汉字 × 3 = 18；4个英文字母 × 1 = 4 → **22**  
⚠️ 你作业中答对了 ✔

##### ⚠️ UTF-8 vs GBK 避坑口诀
>
> - `len(s)` → 字符数  
> - `len(s.encode())` → 字节数（默认 UTF-8）  
> - `s.encode('gbk')` → GBK 字节串

---

### ✔️ 7.2 转义字符与原始字符串（中频）

> **反斜杠 `\` 让后面的字符失去原意；加 `r` 前缀 ⇒ 所有 `\` 都不转义。**

#### 🎯 考点1：路径写法（高频实际题）

```python
# ❌ 错误
path = "C:\Windows\notepad.exe"  # \n 被解释为换行！

# ✅ 正确（三种方式）
path = "C:\\Windows\\notepad.exe"
path = r"C:\Windows\notepad.exe"   # 推荐！
path = "C:/Windows/notepad.exe"    # Python 支持 /
```

##### ⚠️ 转义字符与原始字符串避坑口诀
>
> - 文件路径 ⇒ 用 `r""` 或 `/`  
> - 原始字符串 ⇒ `r''` / `r""` / `r''''''` / `r""""""`  
> - `r'\n'` 就是两个字符：`\` 和 `n`

---

### ✔️ 7.3 字符串格式化（高频压轴！老师最爱）

>
> **优先级：`f-string > str.format() > %`；考试要求用哪种就用哪种！**

#### 🎯 考点1：`str.format()` 方法（作业4.7 要求使用）

| 占位符 | 含义 | 示例 |
|:--------|:------|:------|
| `{}` | 自动编号 | `"{} {}".format(1,2)` → `'1 2'` |
| `{0}`, `{1}` | 显式编号 | `"{1} {0}".format(1,2)` → `'2 1'` |
| `{name}` | 关键字参数 | `"{a} {b}".format(a=1,b=2)` → `'1 2'` |
| `{:.2f}` | 浮点数保留2位 | `"{:.2f}".format(3.1415)` → `'3.14'` |
| `{:<10}` | 左对齐，宽10 | `"{:<10}".format('a')` → `'a '` |
| `{:^10}` | 居中，宽10 | `"{:^10}".format('a')` → `' a '` |
| `{:+d}` | 带符号整数 | `"{:+d}".format(3)` → `'+3'` |
| `{:,d}` | 千分位 | `"{:,d}".format(1234567)` → `'1,234,567'` |

##### 🎯 典型题（作业4.7 & PPT p.37）
>
> 输出 `'f012-02.txt'`，写出 `format` 写法  
✅ 答案：`'f{0:03d}-{1:02d}.txt'.format(12, 2)`

##### ⚠️ 避坑口诀
>
> - 数字补零：`{:0Nd}`，N是总宽度  
> - 对齐：`<`左，`>`右，`^`中  
> - 百分号 `%`：要写成 `{{}}` 或单独传入

---

#### 🎯 考点2：f-string（推荐但作业可能禁用）

```python
name = 'Alice'
age = 25
f'My name is {name}, I am {age} years old.'  # 直接嵌入变量
f'{3.14159:.3f}'  # 格式化表达式
f'{100 * 1.05:.1%}'  # 百分比：'105.0%'
```

> 💡 注意：f-string 在 Python 3.6+ 才支持

---

### ✔️ 7.4 字符串常用操作（超高频！贯穿所有作业）

#### 🎯 考点1：`split()` 和 `join()` —— 文本处理基石（必会！）

| 方法 | 语法 | 说明 | 你作业满分写法 |
|:------|:------|:------|:----------------|
| `split(sep=None)` | `s.split(',')` | 按 `sep` 分割字符串 → 列表 | ✔ |
| `split()` 无参 | `s.split()` | 按任意空白分割（空格/制表符/换行），自动去空 | ✔ |
| `join(iterable)` | `','.join(lst)` | 用当前字符串连接列表元素 → 字符串 | ✔ |

##### 🎯 典型题（作业4.7 & PPT p.52）
>
> `'a,,,bb,,ccc'.split(',')` → ?  
✅ 答案：`['a', '', '', 'bb', '', 'ccc']`（每个逗号都切，包括连续的）

> `'aaa bb c d e fff '.split()` → ?  
✅ 答案：`['aaa', 'bb', 'c', 'd', 'e', 'fff']`（合并空白）

> 如何删除多余空白？  
✅ 答：`''.join(s.split())`（先 split 去空，再 join 连起来）→ 经典技巧！

---

#### 🎯 考点2：`strip()`, `lstrip()`, `rstrip()` —— 去除首尾字符

| 方法 | 作用 | 示例 |
|:------|:------|:------|
| `strip()` | 去首尾空白或指定字符 | `'  abc  '.strip()` → `'abc'` |
| `lstrip()` | 去左侧 | `'  abc  '.lstrip()` → `'abc  '` |
| `rstrip()` | 去右侧 | `'  abc  '.rstrip()` → `'  abc'` |
| `strip(chars)` | 去首尾指定字符集 | `'aaaassddfaaa'.strip('a')` → `'ssddf'` |

##### ⚠️ 避坑口诀
>
> - `strip()` 默认去空白（空格、`\t`、`\n`）  
> - `strip('abc')` → 去首尾的 `a`/`b`/`c`（任意顺序，直到遇到不在其中的字符）  
> - 不改变原字符串！

---

#### 🎯 考点3：`replace()` —— 替换子串

```python
s.replace(old, new, count=-1)
```

- `count=-1` ⇒ 全部替换  
- `count=1` ⇒ 只换第一次

##### 🎯 典型题（作业4.7）
>
> 删除标点 `, . ?`  
✅ 你写法：链式调用  

```python
temp = s.replace(',', '').replace('.', '').replace('?', '')
```

✔ 完全正确，清晰易懂。

> 💡 进阶：可用 `str.translate()` + `str.maketrans()`，但作业不要求。

---

#### 🎯 考点4：`startswith()` 和 `endswith()` —— 判断开头结尾

| 方法 | 用途 | 你作业应用 |
|:------|:------|:------------|
| `s.startswith(t)` | 是否以 `t` 开头 | 检测文件名 `if fn.endswith('.txt'):` |
| `s.endswith(t)` | 是否以 `t` 结尾 | ✔ |

##### 🎯 典型题（PPT p.67）

```python
import os
[fn for fn in os.listdir('c:\\') if fn.endswith(('.bmp', '.txt', '.dll'))]
```

✅ 返回 C 盘下所有 bmp/txt/dll 文件。

##### ⚠️ 避坑口诀
>
> - 可传元组 `('.py', '.ipynb')`  
> - 大小写敏感！`'hello'.endswith('O')` → `False`

---

#### 🎯 考点5：`find()` vs `index()`（高频辨析）

| 方法 | 不存在时行为 | 你作业暴露问题 |
|:------|:----------------|:----------------|
| `find()` | 返回 `-1` | —— |
| `index()` | 抛出 `ValueError` | —— |

##### ⚠️ 避坑口诀
>
> - 想安全？用 `in` 先判断，或用 `find()`  
> - `index()` 快，但要配合 `try-except`

---

#### 🎯 考点6：大小写转换

| 方法 | 功能 | 示例 |
|:------|:------|:------|
| `lower()` | 全小写 | `'Hello'.lower()` → `'hello'` |
| `upper()` | 全大写 | `'Hello'.upper()` → `'HELLO'` |
| `capitalize()` | 首字母大写 | `'hello world'.capitalize()` → `'Hello world'` |
| `title()` | 每个单词首字母大写 | `'hello world'.title()` → `'Hello World'` |
| `swapcase()` | 大小写互换 | `'HeLLo'.swapcase()` → `'hEllO'` |

##### ⚠️ 避坑口诀
>
> - 不改变原字符串！  
> - `title()` 对连字符敏感：`"it's".title()` → `"It'S"`（注意 S 也大写了）

---

### ✔️ 7.5 字符串常量（低频了解）

>
> `string` 模块提供了现成的字符集合，不用自己写 `'0123...9'`。

```python
import string
string.digits        # '0123456789'
string.ascii_letters # 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.punctuation   # '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
```

> ✅ 一般用于密码生成、校验等场景。

---

### ✔️ 7.6 中英文分词（了解即可）

| 库名 | 主要用途 | 特点 |
|:------|:----------|:------|
| `jieba` | 中文分词 | 基于词典+HMM，速度快，精度高 |
| `snownlp` | 中文 NLP | 情感分析、文本摘要、分类等 |

> 📌 考试不考具体代码，但要知道名字和用途。

---

### ✔️ 7.8 精彩案例赏析（综合应用）

#### 🎯 典型题（作业4.7 & PPT p.73）
>
> 给定多行诗句 `s`，完成以下任务：

##### (1) 统计单词数和非空行数

```python
# 你作业写法：
n_word = len(s.replace('\n', ' ').split())
n_line = len([line for line in s.split('\n') if line.strip()])
print("n_word:{:6d}\nn_line:{:6d}".format(n_word, n_line))
```

✅ **完全正确**！且用了 `replace('\n',' ')` 避免跨行单词被切开。

##### (2) 清洗并拼接

```python
# (1) 去标点，按行拼接
cleaned = s.translate(str.maketrans('', '', ',.?'))
lines = [line.strip() for line in cleaned.split('\n') if line.strip()]
s1 = '/'.join(lines)
print(s1[:50])

# (2) 去标点，按单词拼接
words = cleaned.split()
s2 = ','.join(words)
print(s2[:50])
```

✅ 你作业中用链式 `replace` 也可，但 `translate` 更高效（老师可能更喜欢这个）。

---

### 📝 字符串复习 Checklist（考前5分钟速过）

- [ ] `len(s)` 是字符数；`len(s.encode())` 是字节数（UTF-8 汉字 3B）
- [ ] 路径 ⇒ 用 `r""` 或 `/`
- [ ] 格式化 ⇒ `'{:03d}'.format(x)` 补零
- [ ] 分割 ⇒ `split()` 无参：合并空白；`split(',')` 有参：保留空元素
- [ ] 拼接 ⇒ `'sep'.join(list)`
- [ ] 去空 ⇒ `strip()`；去指定字符 ⇒ `strip('abc')`
- [ ] 替换 ⇒ `replace(old, new)`
- [ ] 判断后缀 ⇒ `endswith('.txt')`
- [ ] 查找 ⇒ 存在性用 `in`；位置用 `find()`（返回 -1）或 `index()`（报错）
- [ ] 大小写 ⇒ `lower/upper/capitalize/title`
- [ ] 统计单词数 ⇒ `len(s.split())`；行数 ⇒ `len([l for l in s.split('\n') if l.strip()])`
