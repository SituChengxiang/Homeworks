# 📚 数值计算方法精华总结（含MATLAB实现）- 期中考试复习版

## 📖 第一章 数值计算预备知识

### 1.1 误差分析

#### ✅ 误差类型

| 误差类型 | 定义 | 例子 |
|----------|------|------|
| **模型误差** | 数学模型与实际问题之间的差异 | 用理想模型描述物理现象 |
| **观测误差** | 仪器测量确定参数时的误差 | 用尺子测量长度 |
| **截断误差** | 模型准确解与数值方法准确解之间的误差 | 用泰勒多项式近似 $e^x$ |
| **舍入误差** | 计算机字长有限导致的误差 | 32位浮点数表示 $\pi$ |

#### 📝 截断误差分析（泰勒展开）

```matlab
% 计算 e^(-1) 的近似值，使用泰勒展开前三项
x = -1;
approx = 1 + x + x^2/2; % 1 - 1 + 0.5 = 0.5
exact = exp(x); % ≈ 0.3679
truncation_error = abs(approx - exact); % ≈ 0.1321

% 理论误差界 (n=2)
error_bound = abs(x)^3/factorial(3) * exp(0); % 1/6 ≈ 0.1667
fprintf('实际误差: %.4f, 理论界: %.4f\n', truncation_error, error_bound);
```

#### 📝 舍入误差示例

```matlab
% 在4位浮点数系中计算
format long
x = 1.492 * 1.066; % 精确值 = 1.590472
x_4digit = 1.590;  % 4位近似
rounding_error = abs(x - x_4digit); % = 0.000472
fprintf('舍入误差: %.6f\n', rounding_error);
```

### 1.2 有效数字与误差限

#### 有效数字与误差限的定义

- **绝对误差限**：$|a-x| \leq \delta_x$
- **相对误差限**：$\frac{|a-x|}{|x|} \leq \delta_{r,x}$
- **有效数字**：若近似数 $x$ 的绝对误差限是第 $n$ 位的半个单位，则 $x$ 有 $n$ 位有效数字

#### 💡 例子

```matlab
% 判断有效数字位数
a = sqrt(3); % = 1.732050807568877...
x1 = 1.73;   % 3位有效数字
x2 = 1.7321; % 5位有效数字
x3 = 1.7320; % 4位有效数字

e1 = abs(a - x1); % ≈ 0.00205 < 0.5×10^(-2)
e2 = abs(a - x2); % ≈ 0.00005 < 0.5×10^(-4)
e3 = abs(a - x3); % ≈ 0.00005 < 0.5×10^(-3)

fprintf('x1误差: %.5f, 有效数字: 3位\n', e1);
fprintf('x2误差: %.5f, 有效数字: 5位\n', e2);
fprintf('x3误差: %.5f, 有效数字: 4位\n', e3);
```

### 1.3 算法复杂度

#### 算法复杂度的定义

- **时间复杂度**：算法所需四则运算总次数
- **空间复杂度**：程序运行所需的存储量

#### 💡 例子：计算 $x^{255}$

```matlab
% 算法A (254次乘法)
x = 2;
y = x;
for i = 1:254
    y = y * x;
end

% 算法B (14次乘法) - 二进制分解
x = 2;
powers = [x, x^2, x^4, x^8, x^16, x^32, x^64, x^128];
y = prod(powers); % 14次乘法

fprintf('算法A结果: %d\n', y);
fprintf('算法B结果: %d\n', y);
```

---

## 📖 第二章 计算函数零点的迭代法

### 2.1 不动点迭代法

#### 不动点迭代法的基本思想

将方程 $f(x) = 0$ 转化为 $x = \phi(x)$，迭代格式：
$$x^{(k+1)} = \phi(x^{(k)}),\ k = 0,1,2,\ldots$$

#### 收敛定理

若 $\phi(x) \in C^1[a,b]$，且 $\exists L < 1$ 使得 $|\phi'(x)| \leq L$，则迭代序列收敛于唯一不动点 $x^*$，且有：
$$|x^{(k)} - x^*| \leq \frac{L^k}{1-L}|x^{(1)} - x^{(0)}|$$

#### 不动点迭代法的MATLAB实现

```matlab
function [root, iter] = fixed_point(phi, x0, tol, max_iter)
% 不动点迭代法
% 输入：phi-迭代函数, x0-初值, tol-容差, max_iter-最大迭代次数
% 输出：root-根, iter-迭代次数

x = x0;
for k = 1:max_iter
    x_new = phi(x);
    if abs(x_new - x) < tol
        root = x_new;
        iter = k;
        return;
    end
    x = x_new;
end
root = x;
iter = max_iter;
warning('达到最大迭代次数');
end
```

#### 💡 例子：求解 $x^3 - x - 1 = 0$ 在 $x=1.5$ 附近的根

```matlab
% 收敛的迭代函数
phi1 = @(x) (1 + x).^(1/3);
% 不收敛的迭代函数
phi2 = @(x) x.^3 - 1;

% 使用收敛的迭代函数
[root1, iter1] = fixed_point(phi1, 1.5, 1e-6, 100);
fprintf('收敛迭代: 根 = %.6f, 迭代次数 = %d\n', root1, iter1);

% 使用不收敛的迭代函数
try
    [root2, iter2] = fixed_point(phi2, 1.5, 1e-6, 10);
    fprintf('不收敛迭代: 根 = %.6f, 迭代次数 = %d\n', root2, iter2);
catch
    fprintf('不收敛迭代失败!\n');
end

% 验证
f = @(x) x.^3 - x - 1;
fprintf('验证 f(%.6f) = %.6e\n', root1, f(root1));
```

### 2.2 二分法

#### 二分法的基本思想

设 $f \in C[a,b]$，$f(a)f(b) < 0$，则 $f(x)=0$ 在 $[a,b]$ 内有根。不断二分区间，缩小根的范围。

#### 二分法的MATLAB实现

```matlab
function [c, err, yc] = bisect(f, a, b, delta)
% 二分法
% 输入：f-函数, a,b-区间端点, delta-精度
% 输出：c-近似根, err-误差, yc-f(c)

ya = f(a);
yb = f(b);
if ya * yb > 0
    error('f(a)和f(b)同号，区间内可能无根');
end

max_iter = 1 + round((log(b-a) - log(delta))/log(2));
for k = 1:max_iter
    c = (a + b)/2;
    yc = f(c);
    
    if yc == 0 || (b - a)/2 < delta
        break;
    end
    
    if yb * yc > 0
        b = c;
        yb = yc;
    else
        a = c;
        ya = yc;
    end
end

err = (b - a)/2;
end
```

#### 💡 例子：求解 $x\sin(x) - 1 = 0$ 在 $[0,2]$ 内的根

```matlab
f = @(x) x.*sin(x) - 1;
[a, b] = deal(0, 2);
delta = 1e-6;

[c, err, yc] = bisect(f, a, b, delta);
fprintf('二分法结果: c = %.6f, 误差 = %.2e, f(c) = %.2e\n', c, err, yc);

% 绘制函数图像和根
x = linspace(a, b, 400);
y = f(x);
figure;
plot(x, y, 'b-', [a, b], [0, 0], 'k--', c, yc, 'ro');
title('二分法求根: x\sin(x) - 1 = 0');
xlabel('x'); ylabel('f(x)');
legend('f(x)', 'y=0', '根', 'Location', 'best');
grid on;
```

### 2.3 牛顿迭代法

#### 牛顿迭代法基本思想

在点 $x^{(k)}$ 处用切线近似函数，切线与x轴交点作为下一个近似：
$$x^{(k+1)} = x^{(k)} - \frac{f(x^{(k)})}{f'(x^{(k)})}$$

#### 牛顿迭代法的收敛性

- 对单根，局部二阶收敛
- 对重根 $m$，线性收敛；可修正为：
  $$x^{(k+1)} = x^{(k)} - m\frac{f(x^{(k)})}{f'(x^{(k)})}$$

#### 牛顿迭代法MATLAB实现

```matlab
function [root, iter] = newton(f, df, x0, tol, max_iter)
% 牛顿迭代法
% 输入：f-函数, df-导函数, x0-初值, tol-容差, max_iter-最大迭代次数
% 输出：root-根, iter-迭代次数

x = x0;
for k = 1:max_iter
    fx = f(x);
    dfx = df(x);
    
    % 避免除零错误
    if abs(dfx) < eps
        error('导数接近零，牛顿法失效');
    end
    
    x_new = x - fx/dfx;
    if abs(x_new - x) < tol
        root = x_new;
        iter = k;
        return;
    end
    x = x_new;
end
root = x;
iter = max_iter;
warning('达到最大迭代次数');
end
```

#### 💡 例子1：求解 $xe^x - 1 = 0$ 在 $(0,1)$ 内的根

```matlab
f = @(x) x.*exp(x) - 1;
df = @(x) (1 + x).*exp(x);

[root, iter] = newton(f, df, 0.5, 1e-6, 100);
fprintf('牛顿法结果: 根 = %.8f, 迭代次数 = %d\n', root, iter);

% 验证
fprintf('f(%.8f) = %.2e\n', root, f(root));

% 绘制迭代过程
x = linspace(0, 1, 400);
y = f(x);
figure;
plot(x, y, 'b-', [0, 1], [0, 0], 'k--', root, f(root), 'ro');
title('牛顿法求根: xe^x - 1 = 0');
xlabel('x'); ylabel('f(x)');
legend('f(x)', 'y=0', '根', 'Location', 'best');
grid on;
```

#### 💡 例子2：求二重根 $x^4 - 4x^2 + 4 = 0$ (根为 $\sqrt{2}$)

```matlab
% 函数及其导数
f = @(x) x.^4 - 4*x.^2 + 4;
df = @(x) 4*x.^3 - 8*x;

% 标准牛顿法
[root_std, iter_std] = newton(f, df, 1.5, 1e-6, 100);

% 修正牛顿法（已知重数m=2）
m = 2;
x = 1.5;
for k = 1:100
    x_new = x - m*f(x)/df(x);
    if abs(x_new - x) < 1e-6
        root_mod = x_new;
        iter_mod = k;
        break;
    end
    x = x_new;
end

fprintf('标准牛顿法: 根 = %.8f, 迭代次数 = %d\n', root_std, iter_std);
fprintf('修正牛顿法: 根 = %.8f, 迭代次数 = %d\n', root_mod, iter_mod);
fprintf('精确根: %.8f\n', sqrt(2));
```

---

## 📖 第三章 线性方程组的数值解法

### 3.1 Gauss消去法（列主元）

#### 高斯消元法的核心思想

通过行变换将系数矩阵化为上三角矩阵，再回代求解。**列主元**策略：每一步选择当前列中绝对值最大的元素作主元，避免小主元导致的数值不稳定。

#### 高斯消元法的MATLAB实现

```matlab
function X = uptrbk(A, B)
% 列主元Gauss消去法
% 输入：A-系数矩阵, B-右端向量
% 输出：X-解向量

[N, ~] = size(A);
X = zeros(N, 1);
Aug = [A B];  % 增广矩阵

% 消元过程
for p = 1:N-1
    % 列主元选择
    [~, j] = max(abs(Aug(p:N, p)));
    j = j + p - 1;
    
    % 行交换
    if j ~= p
        temp = Aug(p, :);
        Aug(p, :) = Aug(j, :);
        Aug(j, :) = temp;
    end
    
    % 检查奇异矩阵
    if abs(Aug(p, p)) < eps
        error('矩阵奇异，无唯一解');
    end
    
    % 消元
    for k = p+1:N
        m = Aug(k, p) / Aug(p, p);
        Aug(k, :) = Aug(k, :) - m * Aug(p, :);
    end
end

% 回代
X = backsub(Aug(:, 1:N), Aug(:, N+1));
end

function X = backsub(U, B)
% 回代法求解上三角方程组
n = length(B);
X = zeros(n, 1);
X(n) = B(n) / U(n, n);
for i = n-1:-1:1
    X(i) = (B(i) - U(i, i+1:n) * X(i+1:n)) / U(i, i);
end
end
```

#### 高斯消元法的例子

```matlab
% 求解方程组:
% 2x - 3y + 100z = 1
% x + 10y - 0.001z = 0
% 3x - 100y + 0.01z = 0

A = [2, -3, 100; 
     1, 10, -0.001; 
     3, -100, 0.01];
B = [1; 0; 0];

X = uptrbk(A, B);
fprintf('列主元Gauss消去法解: x = %.4f, y = %.4f, z = %.4f\n', X(1), X(2), X(3));

% 与MATLAB内置函数比较
X_matlab = A\B;
fprintf('MATLAB内置解: x = %.4f, y = %.4f, z = %.4f\n', X_matlab(1), X_matlab(2), X_matlab(3));
```

### 3.2 LU分解

#### LU分界的核心思想

将矩阵A分解为下三角矩阵L和上三角矩阵U的乘积：$A = LU$，通过解两个三角方程组求解。

#### LU分解的MATLAB实现

```matlab
function X = solve_lu(A, B)
% 使用LU分解求解线性方程组
% 输入：A-系数矩阵, B-右端向量
% 输出：X-解向量

% LU分解 (带行交换)
[L, U, P] = lu(A);  % P为置换矩阵

% 解 LY = PB
Y = L \ (P * B);

% 解 UX = Y
X = U \ Y;
end
```

#### LU分解的例子

```matlab
% 求解方程组:
% x + 2y + 6z = 1
% 4x + 8y - z = 2
% -2x + 3y + 5z = 3

A = [1, 2, 6; 4, 8, -1; -2, 3, 5];
B = [1; 2; 3];

X = solve_lu(A, B);
fprintf('LU分解解: x = %.4f, y = %.4f, z = %.4f\n', X(1), X(2), X(3));

% 验证
residual = norm(A*X - B);
fprintf('残差: %.4e\n', residual);
```

### 3.3 迭代法：Jacobi与Gauss-Seidel

#### 雅克比迭代法和高斯迭代法核心思想

将方程组改写为 $x = Bx + g$ 形式，迭代求解。**收敛条件**：矩阵A严格对角占优。

#### 雅克比迭代法和高斯迭代法的MATLAB实现

```matlab
function [X, iter] = jacobi(A, B, X0, tol, max_iter)
% Jacobi迭代法
% 输入：A-系数矩阵, B-右端向量, X0-初始猜测, tol-容差, max_iter-最大迭代次数
% 输出：X-解向量, iter-迭代次数

n = length(B);
X = X0;
iter = 0;

while iter < max_iter
    X_new = zeros(n, 1);
    
    for i = 1:n
        sum = 0;
        for j = 1:n
            if j ~= i
                sum = sum + A(i, j) * X(j);
            end
        end
        X_new(i) = (B(i) - sum) / A(i, i);
    end
    
    % 检查收敛
    if norm(X_new - X) < tol
        X = X_new;
        return;
    end
    
    X = X_new;
    iter = iter + 1;
end
warning('达到最大迭代次数');
end

function [X, iter] = gauss_seidel(A, B, X0, tol, max_iter)
% Gauss-Seidel迭代法
n = length(B);
X = X0;
iter = 0;

while iter < max_iter
    X_old = X;
    
    for i = 1:n
        sum1 = sum(A(i, 1:i-1) .* X(1:i-1)');
        sum2 = sum(A(i, i+1:n) .* X_old(i+1:n)');
        X(i) = (B(i) - sum1 - sum2) / A(i, i);
    end
    
    % 检查收敛
    if norm(X - X_old) < tol
        return;
    end
    
    iter = iter + 1;
end
warning('达到最大迭代次数');
end
```

#### 雅克比迭代法和高斯迭代法的例子

```matlab
% 求解方程组 (严格对角占优):
% 4x - y + z = 7
% 4x - 8y + z = -21
% -2x + y + 5z = 15

A = [4, -1, 1; 
     4, -8, 1; 
     -2, 1, 5];
B = [7; -21; 15];
X0 = [0; 0; 0];  % 初始猜测
tol = 1e-6;
max_iter = 100;

% Jacobi迭代
[X_jacobi, iter_jacobi] = jacobi(A, B, X0, tol, max_iter);
fprintf('Jacobi解 (迭代%d次): x = %.4f, y = %.4f, z = %.4f\n', ...
    iter_jacobi, X_jacobi(1), X_jacobi(2), X_jacobi(3));

% Gauss-Seidel迭代
[X_gs, iter_gs] = gauss_seidel(A, B, X0, tol, max_iter);
fprintf('Gauss-Seidel解 (迭代%d次): x = %.4f, y = %.4f, z = %.4f\n', ...
    iter_gs, X_gs(1), X_gs(2), X_gs(3));

% 精确解 (用于验证)
X_exact = A\B;
fprintf('精确解: x = %.4f, y = %.4f, z = %.4f\n', X_exact(1), X_exact(2), X_exact(3));
```

---

## 📖 第四章 插值与多项式逼近

### 4.1 Lagrange插值

#### 拉格朗日插值法的核心思想

构造n次多项式通过n+1个给定数据点。Lagrange基函数保证在节点处取值为1，其他节点为0。

#### 拉格朗日插值法的MATLAB实现

```matlab
function [C, L] = lagran(X, Y)
% Lagrange插值
% 输入：X-节点向量, Y-函数值向量
% 输出：C-多项式系数(降幂), L-Lagrange基函数系数矩阵

w = length(X);
n = w - 1;
L = zeros(w, w);

% 构造Lagrange基函数
for k = 1:n+1
    V = 1;
    for j = 1:n+1
        if k ~= j
            % conv实现多项式乘法
            V = conv(V, poly(X(j))) / (X(k) - X(j));
        end
    end
    L(k, :) = V;
end

% 计算插值多项式系数
C = Y' * L;
end
```

#### 拉格朗日插值法的例子

```matlab
% 用Lagrange插值计算ln(0.54)
X = 0.4:0.1:0.8;  % 节点
Y = [-0.916291, -0.693147, -0.510826, -0.356675, -0.223144];  % ln(x)值

[C, L] = lagran(X, Y);

% 显示多项式
syms x;
P = poly2sym(C, x);
fprintf('Lagrange插值多项式:\n');
disp(vpa(P, 5));

% 计算ln(0.54)
x_val = 0.54;
y_approx = polyval(C, x_val);
y_exact = log(x_val);
error = abs(y_approx - y_exact);

fprintf('ln(%.2f) ≈ %.6f (精确值: %.6f)\n', x_val, y_approx, y_exact);
fprintf('绝对误差: %.2e\n', error);

% 绘图
x_plot = linspace(0.4, 0.8, 100);
y_plot = polyval(C, x_plot);
figure;
plot(x_plot, y_plot, 'b-', X, Y, 'ro', x_val, y_approx, 'gs');
legend('插值多项式', '数据点', '估计点');
title('Lagrange插值: ln(x)');
xlabel('x'); ylabel('y');
grid on;
```

### 4.2 Newton插值（差商法）

#### 牛顿插值法的核心思想

通过差商表构造插值多项式，具有递推性质，增加节点时只需添加一项。

#### 牛顿插值法的MATLAB实现

```matlab
function [C, D] = newton(X, Y)
% Newton插值
% 输入：X-节点向量, Y-函数值向量
% 输出：C-多项式系数(按Newton形式), D-差商表

n = length(X);
D = zeros(n, n);
D(:, 1) = Y(:);

% 构造差商表
for j = 2:n
    for k = j:n
        D(k, j) = (D(k, j-1) - D(k-1, j-1)) / (X(k) - X(k-j+1));
    end
end

% 提取Newton系数 (对角线元素)
C = diag(D)';
end
```

#### 牛顿插值法的例子

```matlab
% 用Newton插值逼近cos(x)
X = 0:4;  % 节点
Y = cos(X);  % cos(x)值

[C, D] = newton(X, Y);

% 显示差商表
fprintf('差商表:\n');
disp(array2table(D, 'VariableNames', compose('f%d', 0:size(D,2)-1)));

% 构造插值多项式 (符号形式)
syms x;
P = C(1);
term = 1;
for i = 1:length(C)-1
    term = term * (x - X(i));
    P = P + C(i+1) * term;
end
fprintf('Newton插值多项式:\n');
disp(vpa(P, 6));

% 评估多个多项式
x_val = 0.5;
exact_val = cos(x_val);

% 1次插值
P1 = C(1) + C(2)*(x_val - X(1));
% 2次插值
P2 = P1 + C(3)*(x_val - X(1))*(x_val - X(2));
% 3次插值
P3 = P2 + C(4)*(x_val - X(1))*(x_val - X(2))*(x_val - X(3));
% 4次插值
P4 = P3 + C(5)*(x_val - X(1))*(x_val - X(2))*(x_val - X(3))*(x_val - X(4));

fprintf('\n在x = %.1f处的插值结果:\n', x_val);
fprintf('1次: %.6f (误差: %.2e)\n', P1, abs(P1-exact_val));
fprintf('2次: %.6f (误差: %.2e)\n', P2, abs(P2-exact_val));
fprintf('3次: %.6f (误差: %.2e)\n', P3, abs(P3-exact_val));
fprintf('4次: %.6f (误差: %.2e)\n', P4, abs(P4-exact_val));
fprintf('精确值: %.6f\n', exact_val);
```

---

## 📖 第五章 曲线拟合

### 5.1 最小二乘线性拟合

#### 最小二乘法的核心思想

寻找直线 $y = Ax + B$，使误差平方和最小。通过正规方程组求解系数。

#### 最小二乘法的MATLAB实现

```matlab
function [A, B] = lsline(x, y)
% 最小二乘线性拟合
% 输入：x-自变量向量, y-因变量向量
% 输出：A-斜率, B-截距

x_mean = mean(x);
y_mean = mean(y);
sum_x2 = sum((x - x_mean).^2);
sum_xy = sum((y - y_mean) .* (x - x_mean));

A = sum_xy / sum_x2;
B = y_mean - A * x_mean;
end
```

#### 最小二乘法的例子

```matlab
% 拟合直线: y = 1.5x + 1.0
x = 0:4;
y = [1.5, 2.5, 3.5, 5.0, 7.5];  % 带点噪声的数据

% 自定义函数
[A_custom, B_custom] = lsline(x, y);
fprintf('自定义函数: y = %.4fx + %.4f\n', A_custom, B_custom);

% MATLAB内置函数
p = polyfit(x, y, 1);  % p(1)=斜率, p(2)=截距
fprintf('polyfit结果: y = %.4fx + %.4f\n', p(1), p(2));

% 评估拟合效果
x_fit = linspace(min(x), max(x), 100);
y_fit = p(1)*x_fit + p(2);
y_exact = 1.5*x_fit + 1.0;

% 计算R² (决定系数)
y_mean = mean(y);
SS_tot = sum((y - y_mean).^2);
SS_res = sum((y - (p(1)*x + p(2))).^2);
R2 = 1 - SS_res/SS_tot;

% 绘图
figure;
plot(x, y, 'ro', 'MarkerSize', 8, 'LineWidth', 2, 'DisplayName', '数据点');
hold on;
plot(x_fit, y_fit, 'b-', 'LineWidth', 2, 'DisplayName', ['拟合直线 (R² = ', num2str(R2, '%.4f'), ')']);
plot(x_fit, y_exact, 'k--', 'DisplayName', '真实直线');
legend('Location', 'best');
title('最小二乘线性拟合');
xlabel('x'); ylabel('y');
grid on;
```

### 5.2 多项式拟合

#### 多项式拟合的核心思想

寻找n次多项式 $P(x) = a_0 + a_1x + \ldots + a_nx^n$，使误差平方和最小。

#### 多项式拟合的MATLAB实现

```matlab
function C = lspoly(X, Y, M)
% 多项式最小二乘拟合
% 输入：X-自变量向量, Y-因变量向量, M-多项式次数
% 输出：C-多项式系数(降幂)

n = length(X);
B = zeros(1, M+1);
F = zeros(n, M+1);

% 构造设计矩阵
for k = 1:M+1
    F(:, k) = X'.^(k-1);
end

A = F' * F;
B = F' * Y';
C = (A \ B)';
C = flipud(C);  % 降幂排列
end
```

#### 💡 例子：拟合Runge函数

```matlab
% Runge函数: f(x) = 1/(1+25x²)
f = @(x) 1./(1 + 25*x.^2);

% 生成数据点
x = linspace(-1, 1, 11);  % 11个等距点
y = f(x);

% 不同次数的多项式拟合
x_plot = linspace(-1, 1, 1000);
y_exact = f(x_plot);

figure;
plot(x_plot, y_exact, 'k-', 'LineWidth', 2, 'DisplayName', '精确值');
hold on;
plot(x, y, 'ro', 'MarkerFaceColor', 'r', 'DisplayName', '数据点');

% 2次多项式
p2 = polyfit(x, y, 2);
y2 = polyval(p2, x_plot);
plot(x_plot, y2, 'b--', 'DisplayName', '2次多项式');

% 5次多项式
p5 = polyfit(x, y, 5);
y5 = polyval(p5, x_plot);
plot(x_plot, y5, 'g-.', 'DisplayName', '5次多项式');

% 10次多项式 (出现Runge现象)
p10 = polyfit(x, y, 10);
y10 = polyval(p10, x_plot);
plot(x_plot, y10, 'm:', 'DisplayName', '10次多项式');

legend('Location', 'best');
title('Runge现象: 高次多项式拟合震荡');
xlabel('x'); ylabel('y');
grid on;
```

### 5.3 三次样条插值

#### 三次样条插值的核心思想

分段构造三次多项式，在节点处保证函数值、一阶导数和二阶导数连续，避免高次多项式的震荡。

#### 三次样条插值的MATLAB内置函数

```matlab
% MATLAB内置函数:
% pp = csapi(x, y)         - not-a-knot端点条件
% pp = csape(x, y, 'cond') - 指定端点条件
% y_interp = spline(x, y, xi) - 三次样条插值
```

#### 💡 例子：比较样条与多项式插值

```matlab
% 原始函数
f = @(x) (x.^2 - 3*x + 5) .* exp(-5*x) .* sin(x);

% 生成稀疏数据点
x = 0:0.12:1;
y = f(x);

% 生成密集点用于绘图
x_fine = 0:0.01:1;
y_exact = f(x_fine);

% 6次多项式插值
p6 = polyfit(x, y, 6);
y_poly = polyval(p6, x_fine);

% 三次样条插值
y_spline = spline(x, y, x_fine);

% 计算误差
err_poly = max(abs(y_exact - y_poly));
err_spline = max(abs(y_exact - y_spline));

% 绘图
figure;
plot(x_fine, y_exact, 'k-', 'LineWidth', 2, 'DisplayName', '精确值');
hold on;
plot(x, y, 'ro', 'MarkerFaceColor', 'r', 'DisplayName', '数据点');
plot(x_fine, y_poly, 'b--', 'DisplayName', ['6次多项式 (误差: ', num2str(err_poly, '%.2e'), ')']);
plot(x_fine, y_spline, 'g-', 'LineWidth', 1.5, 'DisplayName', ['三次样条 (误差: ', num2str(err_spline, '%.2e'), ')']);
legend('Location', 'best');
title('样条插值 vs 多项式插值');
xlabel('x'); ylabel('y');
grid on;

% 显示误差
fprintf('6次多项式最大误差: %.2e\n', err_poly);
fprintf('三次样条最大误差: %.2e\n', err_spline);
```

---

## 🚀 期中考试重点与技巧

### 1. 核心概念总结

| 章节 | 重点概念 | 考试关键点 |
|------|----------|-----------|
| **第一章** | 误差类型、有效数字、算法复杂度 | 能区分四种误差，计算有效数字位数，分析算法复杂度 |
| **第二章** | 不动点迭代、二分法、牛顿法 | 理解收敛条件，能证明/判断收敛性，处理单根与重根 |
| **第三章** | Gauss消去法、LU分解、迭代法 | 会实施列主元策略，理解收敛条件，能计算条件数 |
| **第四章** | Lagrange插值、Newton插值 | 能构造插值多项式，理解误差公式，识别Runge现象 |
| **第五章** | 最小二乘、样条插值 | 能建立正规方程，理解样条优点，避免高次震荡 |

### 2. 常见陷阱与解决方案

1. **小主元问题**：使用列主元或带尺度选主元

   ```matlab
   [L,U,P] = lu(A);  % 内置列主元
   ```

2. **Runge现象**：避免高次全局多项式，改用分段低次插值

   ```matlab
   yi = interp1(x,y,xi,'spline');  % 三次样条
   ```

3. **牛顿法对重根收敛慢**：使用修正牛顿法

   ```matlab
   x_new = x - m*f(x)/df(x);  % m为重数
   ```

4. **迭代法不收敛**：检查矩阵是否严格对角占优

   ```matlab
   diag_dominant = all(abs(diag(A)) > sum(abs(A),2) - abs(diag(A)));
   ```

5. **舍入误差累积**：使用稳定算法，如Horner方法计算多项式

   ```matlab
   y = polyval(p,x);  % 比直接计算x^n更稳定
   ```

### 3. MATLAB函数速查表

| 任务 | 函数 | 例子 |
|------|------|------|
| 解线性方程组 | `X = A\B` | `X = A\B` |
| LU分解 | `[L,U,P] = lu(A)` | `[L,U,P] = lu(A)` |
| 多项式求根 | `roots(p)` | `roots([1,0,-2])` |
| 多项式求值 | `polyval(p,x)` | `polyval([1,2,3],2)` |
| 多项式拟合 | `p = polyfit(x,y,n)` | `p = polyfit(x,y,2)` |
| 一维插值 | `yi = interp1(x,y,xi,'spline')` | `yi = interp1(x,y,xi,'spline')` |
| 三次样条 | `pp = csapi(x,y)` | `pp = csapi(x,y)` |
| 求函数零点 | `fzero(f,x0)` | `fzero(@(x)x^2-2,1)` |

### 4. 考试技巧

1. **先易后难**：先做有把握的题，确保拿到基础分
2. **显示中间步骤**：即使最终答案错误，正确的中间步骤也能得分
3. **检验合理性**：检查答案是否合理（如插值应在数据点之间，迭代根应在区间内）
4. **注意精度要求**：题目要求的精度（小数点后几位）要严格遵守
5. **标注单位**：数值结果要标注单位（如果适用）
6. **时间分配**：
   - 选择/填空题：20%
   - 计算题：50%
   - 证明/分析题：30%

> 💡 **最后提示**：考试时先写伪代码，再转MATLAB，避免低级语法错误。对数值方法，稳定性往往比精确度更重要！

**祝你期中考试顺利！** 如有具体问题需要详解，随时问我。
