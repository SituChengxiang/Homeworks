# Python期中补天复习

markdown版本 有条件的放到Jupter里头跑一下

## 📚 一、核心基础语法

### 1. Python 基本特征（选择题高频）

- **解释型（一边编译一遍跑）、动态类型（不用提前声明类型）、强类型、缩进强制**  
- **胶水语言**：可调用 C/Fortran 写的模块（如 NumPy, SciPy 底层）
- **UTF-8 默认**（Python 3.x），中文支持好
- **PEP 8 规范**：4空格缩进、运算符两侧空格、不超过79字符/行、`#`注释 & `"""doc"""`

### 2. 变量与内存模型

- **变量是对象的引用（标签），不是容器本身**  

  ```python
  a = [1, 2]; b = a; b[0] = 99  # ⇒ a 也变 [99, 2]
  ```

- **不可变对象**：`int`, `float`, `str`, `tuple` — 修改 = 新对象  
- **Python的数值对象**：`int`,`float`,`complex`。`x = 3+4j`，`x.real`和`x.imag`的类型均为`float`
- **可变对象**：`list`, `dict`, `set` — 可原地修改（`append`, `+=`, `sort`）

### 3. 运算符

| 类别 | 运算符 | 示例 | 注意点 |
|---|---|---|---|
| **算术** | `+ - * / // % **` | `5//2→2`, `2**3→8` | `/` 永远浮点；`//` 向下取整（负数注意）。对列表、元组、字符串`*`整数操作是潜复制，两者内存地址相同|
| **比较** | `< <= == != >= >` | `1 == 1.0 → True` | 支持链式 `1 < x < 10`，浮点比较用`abs(x1-x2)<1e^-6`，如果这个表达式成立，则认为两者相等 |
| **逻辑** | `and or not` | `x and y`, `x or y` | **短路求值**：`False and expr` 不算 `expr`；`True or expr` 不算 `expr` |
| **成员** | `in`, `not in` | `'a' in 'abc'`, `3 not in [1,2]` | 对 `str`, `list`, `tuple`, `set`, `dict(keys)` 均支持 |
| **身份** | `is`, `is not` | `x is y` 比地址 | ≠ `==`（内容）；小整数缓存 `(-5~256)`、短字符串驻留 |
| **位运算** | `& \| ^ ~ << >>` | `{1,2} \| {2,3}` 是并集 | 集合运算 & 位运算 符号相同！但对象不同 |
| **赋值** | `=`, `+=`, `*=`, etc | `a += [1]` vs `a = a + [1]` | **关键区别**：<br> `list += iterable` 是 `extend()` — **原地修改** ✅<br> `list = list + [...]` 是 `+` — **新对象** ❌（拷贝开销大）|

### 4. 逻辑运算符补充：惰性求值

- **`and` 返回第一个 falsy 值或最后一个 truthy 值**

  ```python
  [] and 'hello'  # → []
  1 and 0 and 2   # → 0
  1 and 2         # → 2
  ```

- **`or` 返回第一个 truthy 值或最后一个 falsy 值**

  ```python
  '' or 0 or 'hi'  # → 'hi'
  '' or []         # → []
  ```

- 应用：默认值赋值（`x = y or "default"`），**但注意 falsy 值问题**（`0`, `""`, `[]` 都会触发 default）

- **`and`/`or` 的惰性求值特性**：

  ```python
  3 and 5  # 返回 5（如果第一个为True，返回第二个值）
  3 or 5   # 返回 3（如果第一个为True，直接返回第一个值）
  0 and 5  # 返回 0（如果第一个为False，直接返回第一个值）
  ```

- **短路特性**：`False and expr` 不计算 `expr`；`True or expr` 不计算 `expr`
- 典型应用：`x = y or "default"`，但注意 `0, "", [], False` 都会触发 default

### 5. **矩阵乘法运算符 @** (2.2.6)

- Python 3.5+ 新增，主要用于科学计算
- 与 `numpy` 配合使用：

  ```python
  import numpy as np
  a = np.ones((2,2))
  a @ a  # 矩阵乘法 [[2., 2.], [2., 2.]]
  a * a  # 元素级乘法 [[1., 1.], [1., 1.]]
  ```

### 6. **位运算符与集合运算符** (2.2.4)

- **位运算符** `& | ^ << >> ~` 与**集合运算符**重名但不同：

  ```python
  {1,2,3} | {3,4,5}  # 集合并集 {1,2,3,4,5}
  5 | 3              # 位或 7 (101 | 011 = 111)
  ```

- **集合差集**使用减号：`{1,2,3} - {2,3} = {1}`

### 7. **成员测试与同一性测试** (2.2.3)

- **`in`** 检查元素是否在序列/集合中

  ```python
  g = (i**2 for i in range(0,10,2))
  10 in g # False
  list(g) # [], in会遍历整个序列，用过的就没了
  ```

- **`is`** 检查是否为同一对象（相同内存地址）

  ```python
  x = [1,2]; y = [1,2]; x == y  # True (值相同)
  x is y  # False (不同对象)
  x = y; x is y  # True (指向同一对象)
  ```

---

## 📜 二、程序控制结构

### 1. 分支结构 `if-elif-else`

- 冒号 `:` + 缩进；支持 `if 表达式:`
- **三元运算符**：`值1 if 条件 else 值2`

  ```python
  max_val = a if a > b else b
  sign = 'pos' if x > 0 else 'neg' if x < 0 else 'zero'
  ```

### 2. 循环结构

#### `for` 循环（**重点！高频考程序填空/改错**）

```python
for var in iterable:       # iterable: list/str/range/dict(set)/zip/enumerate
    ...
else:                      # 正常结束（非break）执行，少用但会考
    ...
```

- 常见迭代对象：
  - `range(stop)` / `range(start, stop, step)`（`random.randint()`是左闭右闭，而`range()`是左闭右开）
  - `enumerate(seq) → (index, item)`
  - `zip(seq1, seq2) → (item1, item2)`
  - `dict`: 遍历 **键**；用 `.items()` 得 `(k, v)`

#### `while` 循环

```python
while condition:
    ...
```

- 避免死循环；注意循环变量更新位置

#### **⚠️ 经典陷阱**

- **遍历时修改 list（`remove`, `del`, `insert`）极易出错（跳过/越界）**

  ```python
  # WRONG
  for x in lst:
      if x % 2 == 0:
          lst.remove(x)   # 索引错位！

  # RIGHT 方法：倒序遍历 or filter 列表推导式
  lst = [x for x in lst if x % 2 != 0]
  for i in range(len(lst)-1, -1, -1):
      if lst[i] % 2 == 0:
          lst.pop(i)
  ```

#### `break` / `continue` / `else`

- `break`：跳出当前循环，一旦 `break` 语句被执行，将使得 `break` 语句所属层次的循环提前结束；
- `continue`：跳过本次剩余，进入下次循环
- `else`：仅当循环**正常结束（无break）** 时执行  

  ```python
  for i in range(10):
      if i == 5:
          break
  else:
      print("No break")   # ← 不会执行
  ```

---

## 📦 三、核心数据结构（Ch3 + Ch4）

### 比较总表（高频选择/判断）

| 特性 | **list** | **tuple** | **str** | **dict** | **set** |
|---|---|---|---|---|---|
| 可变？ | ✅ | ❌ | ❌ | ✅ | ✅ |
| 有序？ | ✅ | ✅ | ✅ | ❌ (Py3.7+ 插入有序但官方仍称无序) | ❌ |
| 允许重复？ | ✅ | ✅ | ✅ | key ❌, value ✅ | ❌ |
| 创建空 | `[]` / `list()` | `()` / `tuple()` | `''` | `{}` / `dict()` | `set()`（`{}` 是空 dict！）|
| 元素要求 | 任意 | 任意 | Unicode字符 | key: hashable | 元素: hashable |
| 查找速度 | O(n) | O(n) | O(n) | O(1) | O(1) |
| 常用方法 | `append`, `pop`, `sort`... | `count`, `index` | `split`, `find`, `replace`... | `get`, `keys`, `items`... | `add`, `discard`, `&`, `\|`... |

- **不可变的元组中的列表是可变的**

### 1. 列表 `list`

#### 创建

`dir()`, `sorted()`, `list()` 这三个内置函数返回值的类型都是`list`

```python
a = [1,2,3]
a = list(range(5))
a = [x**2 for x in range(10)]  # 列表推导式
a = [0]*5                      # [0,0,0,0,0]
```

#### 常用的列表的方法：增删查改（**务必区分是否原地修改**）

| 操作 | 原地？ | 返回 | 说明 |
|---|---|---|---|
| `append(x)` | ✅ | `None` | 尾加1元素（可以是字符串） |
| `extend(iter)` | ✅ | `None` | 尾加多个 |
| `insert(i,x)` | ✅ | `None` | 插入 |
| `pop([i])` | ✅ | 弹出元素 | 默认尾；可索引 |
| `remove(x)` | ✅ | `None` | 删第一个 `x` |
| `del lst[i]` | ✅ | — | 按索引删 |
| `clear()` | ✅ | `None` | 清空 |
| `sort()` | ✅ | `None` | 原地排序；`key=`, `reverse=` |
| `reverse()` | ✅ | `None` | 原地翻转 |
| `+` | ❌ | 新 list | 慢！拷贝 |
| `+=` | ✅ | — | = `extend()`，快！|
| `copy()` | ❌ | 新 list（浅拷贝，指向同一个内存地址） | `b = a[:]` 同效 |

#### 切片（**万能，但易错边界**）

```python
lst = [0,1,2,3,4,5]
lst[:]      # [0,1,2,3,4,5]
lst[1:4]    # [1,2,3]  → [start, end)
lst[::2]    # [0,2,4]
lst[::-1]   # [5,4,3,2,1,0] — 反转副本（非原地）
lst[1:4] = [99]   # → [0,99,4,5]  批量替换/删/插（原地）
del lst[::2]      # 隔一个删一个（原地）
```

> `lst[i:j]` 等价于 `lst[i:j:1]`  
> `lst[::-1]` vs `lst.reverse()` vs `reversed(lst)`：切片反转返回新的列表；`lst.reverse()`是列表的方法，改变源列表；`reversed()`是Python内置函数，返回反转的迭代器对象，源列表不变

#### 列表推导式（**高频考点**）

基本：`[expression for var in iterable if condition]`  

```python
squares = [x**2 for x in range(1, 11)] # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
list_a = [1, 2, 3]
list_b = [x * 10 for x in list_a] # [10, 20, 30]
```

嵌套：

```python
# 平铺
flat = [num for sub in [[1,2],[3,4]] for num in sub] # [1,2,3,4]

# 条件过滤
evens_sq = [x**2 for x in range(10) if x%2==0] # [0, 4, 16, 36, 64]

# 枚举下标
indices = [i for i, x in enumerate(lst) if x == 'a']

fruits = ["苹果", "香蕉", "橙子"]
indexed_fruits = [(idx, fruit) for idx, fruit in enumerate(fruits)] 
# [(0, '苹果'), (1, '香蕉'), (2, '橙子')][1,6]

words = ["Python", "C++", "Java", "Go"]
long_words = [(idx, word) for idx, word in enumerate(words) if len(word) > 4]
# [(0, 'Python'), (2, 'Java')][3,7]

# 矩阵转置
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transpose = [[row[i] for row in matrix] for i in range(3)]
```

习题：

```python
# 问题：设a是一个列表，写列表推导式，得到：a中的偶数的下标所构成列表
[i for i, x in enumerate(a) if x%2 == 0]
# 设a和b是两个列表，写列表推导式，得到：a和b相同位置上的元素相除所构成的列表
[x/y for (x,y) in zip(a,b)]
# 设a和b是两个列表，写列表推导式，得到：a和b相同位置上的元素相除所构成的列表，且判断除数（分母）不能为零
[x/y for (x,y) in zip(a,b) if y !=0]
```

---

### 2. 元组 `tuple`（轻量、安全）

- 用法同 `list`，但**不可~~修改~~**
- 单元素元组必须加逗号：`(1,)`
- 可作为 `dict` 的键、`set` 的元素（因 hashable）
- `zip`, `enumerate` 返回 **迭代器**，需 `list(...)` 查看内容

#### 生成器推导式（**重点！与列表推导式对比**）

```python
g = (x**2 for x in range(10))  # 圆括号！生成器对象
type(g)  # <class 'generator'>

next(g)  # 0 → 1 → 4 → ...
list(g)  # 耗尽；再 list(g) → []
```

| 特性 | 列表推导式 `[...]` | 生成器推导式 `(...)` |
|---|---|---|
| 内存 | 一次性存所有元素 | **极小**（只存生成逻辑） |
| 执行 | 立即计算 | **惰性求值**（用时生成） |
| 复用 | 可多次遍历 | **一次性**（遍历完为空） |
| 适用 | 数据量小；需多次用 | 大数据；只需遍历一次；`all()`, `any()`, `for`, `in` |

---

### 3. 字符串 `str`（Ch7 — 重点！）

#### 基本性质

- **不可变序列**；支持索引、切片、`in`、`+`, `*`
- 单引号/双引号/三引号；可嵌套  

  ```python
  s = '''He said: "Let's go".''' 
  ```

#### 编码（理解即可）

- 内部 Unicode；存盘/网络用 `UTF-8`（1英文=1B, 1中文=3B）或 `GBK`（1英1B, 1中2B）
- `encode()` → `bytes`；`decode()` → `str`

#### 转义与原始字符串

```python
print("C:\\Windows")      # 需 \\
print(r"C:\Windows")      # 原始字符串，\ 不转义
```

#### 格式化（**三种方式，推荐 f-string**）

```python
name, age = "Dong", 39

# % 格式（旧）
"Name: %s, Age: %d" % (name, age)

# .format()（过渡）
"Name: {0}, Age: {1}".format(name, age)
"Name: {n}, Age: {a}".format(n=name, a=age)

# f-string ✅（Python 3.6+，**最推荐**）
f"Name: {name}, Age: {age}"
f"{3.14159:.2f}"  # 3.14；支持表达式
```

#### 常用方法（**必背高频**）

| 功能 | 方法 | 注意 |
|---|---|---|
| 查找位置 | `find(sub)` / `rfind(sub)` | 不存在返 `-1` |
|  | `index(sub)` / `rindex(sub)` | 不存在 **抛异常** |
| 出现次数 | `count(sub)` | 非重叠计数 |
| 切分 | `split(sep)` / `rsplit(sep)` | `None` → 空白分；自动去空串 |
| 连接 | `sep.join(iterable)` | `iterable` 中必须全是 `str`！ |
| 替换 | `replace(old, new[, count])` | 返回新串 |
| 去空白 | `strip()` / `lstrip()` / `rstrip()` | 可指定字符集 |
| 大小写 | `upper()` / `lower()` / `swapcase()` / `title()` | 非字母不变 |
| 判断 | `startswith()` / `endswith()` | 可 tuple 多匹配 |
|  | `isalnum()` / `isdigit()` / `isspace()`... | `isdigit` < `isnumeric`（含汉字、罗马）|


问题：`'a,b,,d,,'.split(',')`返回的列表包含几个元素？  
答案：6个（5个逗号分出来是6个元素）→ `['a','b','','d','','']`

问题：设x为一个整数列表，将其转化为逗号分隔的字符串  
答案：`','.join(map(str, x))`

问题：设`s='IF you shed tears when you miss the sun,you also miss the stars.'`，如何得到其中以字母's'开头的单词组成的列表？  
答案：
```python
# 基本方法
s_words = [word for word in s.split() if word.lower().startswith('s')]
print(s_words)  # 输出: ['shed','sun,','stars.']

# 进阶方法（去掉标点符号）
s_words = [word for word in s.replace(',','').replace('.','').split() if word.lower().startswith('s')]
print(s_words)  # 输出: ['shed','sun','stars']
```

##### ⚠️ 易错点

- `split()` 不给参数 vs 给参数：

  ```python
  "a  b".split()      # → ['a','b'] （合并空格）
  "a,,b".split(',')   # → ['a', '', 'b'] （不合并，空格单独拿出来了）
  ```

- `join` 必须是字符串序列：

  ```python
  ','.join([1,2,3])   # ❌ TypeError
  ','.join(map(str, [1,2,3]))  # ✅ "1,2,3"
  ```

---

### 4. 字典 `dict` & 集合 `set`

#### 字典 `dict`

- 创建：

  ```python
  d = {'a':1, 'b':2}
  d = dict(a=1, b=2)
  d = dict(zip(['a','b'], [1,2]))
  d = dict(zip(k,d)) # 以序列k的元素为键，以序列d的元素为值，创建字典
  d = {k:0 for k in keys}   # 字典推导式
  # 以序列k的元素为键，以0为对应的值，创建字典
  dict(zip(k, (0 for i in range(len(k)))))
  {key:0 for key in k}
  dict.fromkeys(k, 0)
  ```

- 访问：
  - `d[key]` — 不存在 ⇒ **KeyError**  
  - `d.get(key, default)` — 不存在 ⇒ `default`  
  - `d.setdefault(key, default)` — 不存在则设并返回 `default`
- 遍历：

  ```python
  for k in d: ...          # 键
  for v in d.values(): ... # 值
  for k, v in d.items(): ... # 键值对
  ```

- 修改：
  - `d[key] = value` — 存在则改，无则增
  - `d.update(other_dict)` — 合并；同 key 覆盖
- 删除：
  - `del d[key]`
  - `d.pop(key[, default])`
  - `d.popitem()` — 随机弹（Py3.7+ LIFO）
  - `d.clear()`

#### 集合 `set`

- 创建：`s = {1,2,3}`；空集 `set()`（`{}` 是空字典！）
- 运算符（**与位运算同符！**）：
  - 并集：`|` 或 `union()`  
  - 交集：`&` 或 `intersection()`  
  - 差集：`-` 或 `difference()`  
  - 对称差：`^` 或 `symmetric_difference()`（集合A与集合B的对称差集定义为集合A与集合B中所有不属于A∩B的元素的集合）
- 方法：
  - `add(x)`：增1元素  
  - `update(iter)`：增多个  
  - `remove(x)`：删，无则 **异常**  
  - `discard(x)`：删，无则 **静默**  
  - `pop()`：随机弹1元素  

> ✅ 典型应用：去重（`set(lst)`）、成员快速检查、集合逻辑判断  
>
> ```python
> # 判断 a 所有元素 ∈ b？
> set(a) <= set(b)   # 子集
> # a 与 b 无交集？
> set(a).isdisjoint(b)
> ```

---

## 🧩 四、高频题型 & 易错陷阱汇总

### 🔹 选择/判断题易错点

1. `{}` 是空 **字典**，空集是 `set()`
2. `list.sort()` 返回 `None`，`sorted(list)` 返回新 list
3. `str.replace()` 不修改原串（str 不可变）
4. `+=` 对 list 是原地修改；`+` 是生成新对象
5. `0.1 + 0.2 == 0.3` → `False`（浮点精度问题）
6. `is` 比地址；小整数 `(-5~256)` 缓存，`a = 1000; b = 1000; a is b` 可能 False；`a = 100; b = 100; a is b` True
7. `and`/`or` 返回的是**操作数本身**，不是 `True`/`False`
8. `for` 遍历中修改 list 极易出错（跳过元素）
9. 生成器只能遍历一次
10. `index()` 找不到抛异常；`find()` 返回 -1

### 🔹 程序填空/改错高频考点

1. 用 `index()` 找所有位置 → 改用 `enumerate` 或循环 `index(..., start)`
2. 删除 list 中所有某元素 → 用列表推导式 `[x for x in lst if x != val]` 或倒序遍历 `pop`
3. 连接数字列表为字符串 → `','.join(map(str, nums))`
4. 字典初始化 → `dict.fromkeys(keys, 0)` 或 `{k:0 for k in keys}`
5. 交换两变量 → `a, b = b, a`（多重赋值）

### 🔹 编程题模板

1. **统计字符频次**：

   ```python
   from collections import Counter
   s = "hello"
   freq = Counter(s)            # 字典形式
   # 或手动
   d = {}
   for ch in s:
       d[ch] = d.get(ch, 0) + 1
   ```

2. **过滤列表**：

   ```python
   evens = [x for x in lst if x % 2 == 0]
   indices = [i for i, x in enumerate(lst) if x == 'a']
   ```

3. **字典排序**：

   ```python
   sorted(d.items())                     # 按 key
   sorted(d.items(), key=lambda x: x[1])  # 按 value
   ```

4. **集合应用**：

   ```python
   # a 所有元素 ∈ b？
   set(a) <= set(b)
   # a 与 b 交集为空？
   set(a) & set(b) == set()
   # 等价于：
   set(a).isdisjoint(b)
   ```

---

## 📖 最后叮嘱（今晚冲刺）

1. **重点优先级**：  
   `list`操作`（append/extend/pop/remove/切片/推导式）` > `str`方法`（find/index/count/split/join/replace）` > `dict/set`创建与访问 > `控制结构（for/while陷阱）` > 运算符细节

2. **手写几遍**：  
   - 列表推导式找下标：`[i for i,x in enumerate(lst) if x=='a']`  
   - 安全字典访问：`d.get(key, default)`  
   - 生成器 vs 列表推导式区别  
   - `+=` vs `+` 对 list 的影响

3. **考前30分钟**：  
   快速过一遍 **易错点列表**（上述第4节）；重点看 `index/find`、`+=`、生成器、空集创建。
